scalar JSON
scalar DateTime

type Query {
    event(id: ID!): Event
    events(status: EventStatus, first: Int, after: String): EventConnection!
    queueStats: QueueStats!

    # Endpoint queries
    endpoint(id: ID!): Endpoint
    endpoints(
        status: EndpointStatus
        first: Int
        after: String
    ): EndpointConnection!

    # Event type queries
    eventType(id: ID!): EventType
    eventTypeByName(name: String!): EventType
    eventTypes(first: Int, after: String): EventTypeConnection!
}

type Mutation {
    # Legacy: create event with direct destination URL
    createEvent(input: CreateEventInput!, idempotencyKey: String!): Event!

    # New: create event by event type (fans out to all subscribed endpoints)
    sendEvent(input: SendEventInput!, idempotencyKey: String!): [Event!]!

    replayEvent(id: ID!): Event!

    # Batch retry operations
    retryEvents(ids: [ID!]!): BatchRetryResult!
    retryEventsByStatus(status: EventStatus!, limit: Int): BatchRetryResult!
    retryEventsByEndpoint(
        endpointId: ID!
        status: EventStatus
        limit: Int
    ): BatchRetryResult!

    # Endpoint mutations
    createEndpoint(input: CreateEndpointInput!): Endpoint!
    updateEndpoint(id: ID!, input: UpdateEndpointInput!): Endpoint!
    deleteEndpoint(id: ID!): Boolean!
    pauseEndpoint(id: ID!): Endpoint!
    resumeEndpoint(id: ID!): Endpoint!

    # Secret rotation mutations
    rotateEndpointSecret(id: ID!): EndpointSecretRotation!
    clearPreviousSecret(id: ID!): Endpoint!

    # Event type mutations
    createEventType(input: CreateEventTypeInput!): EventType!
    updateEventType(id: ID!, input: UpdateEventTypeInput!): EventType!
    deleteEventType(id: ID!): Boolean!

    # Transformation testing
    testTransformation(input: TestTransformationInput!): TransformationTestResult!
}

# Transformation testing types
input TestTransformationInput {
    code: String!
    webhook: WebhookInput!
}

input WebhookInput {
    method: String
    url: String!
    headers: JSON
    payload: JSON!
}

type TransformationTestResult {
    success: Boolean!
    result: TransformationResult
    error: String
    executionMs: Int!
}

type TransformationResult {
    method: String!
    url: String!
    headers: JSON
    payload: JSON
    cancel: Boolean!
}

type EndpointSecretRotation {
    endpoint: Endpoint!
    newSecret: String!
}

type Event {
    id: ID!
    idempotencyKey: String!
    clientId: String
    eventType: String
    endpointId: ID
    destination: String!
    payload: JSON!
    headers: JSON
    status: EventStatus!
    priority: Int!
    scheduledAt: DateTime
    attempts: Int!
    maxAttempts: Int!
    nextAttemptAt: DateTime
    deliveredAt: DateTime
    createdAt: DateTime!
    updatedAt: DateTime!
    deliveryAttempts: [DeliveryAttempt!]!

    # Resolved fields
    endpoint: Endpoint
}

type DeliveryAttempt {
    id: ID!
    eventId: ID!
    statusCode: Int
    responseBody: String
    error: String
    durationMs: Int!
    attemptNumber: Int!
    attemptedAt: DateTime!
}

type Endpoint {
    id: ID!
    clientId: String!
    url: String!
    description: String
    eventTypes: [String!]!
    status: EndpointStatus!

    # Content-based routing filter (optional)
    # If set, events are only delivered if they match the filter conditions
    filter: JSON

    # Payload transformation (optional)
    # JavaScript code to transform webhook payload before delivery
    transformation: String

    # FIFO (ordered delivery) configuration
    # When enabled, events are delivered sequentially - one at a time
    fifo: Boolean!
    # JSONPath expression to extract partition key from payload
    # Events with same partition key are delivered in order
    # Different partition keys can be processed in parallel
    fifoPartitionKey: String

    # Retry configuration
    maxRetries: Int!
    retryBackoffMs: Int!
    retryBackoffMax: Int!
    retryBackoffMult: Float!

    # Delivery configuration
    timeoutMs: Int!
    rateLimitPerSec: Int!

    # Circuit breaker configuration
    circuitThreshold: Int!
    circuitResetMs: Int!

    customHeaders: JSON

    # Secret rotation (secrets are not exposed, only metadata)
    hasCustomSecret: Boolean!
    secretRotatedAt: DateTime

    createdAt: DateTime!
    updatedAt: DateTime!

    # Computed fields
    stats: EndpointStats!
    recentEvents(first: Int): [Event!]!
}

type EndpointStats {
    totalEvents: Int!
    delivered: Int!
    failed: Int!
    pending: Int!
    successRate: Float!
    avgLatencyMs: Float!
}

type EventType {
    id: ID!
    clientId: String!
    name: String!
    description: String
    schema: JSON
    schemaVersion: String
    createdAt: DateTime!
    updatedAt: DateTime!
}

type EventTypeConnection {
    edges: [EventTypeEdge!]!
    pageInfo: PageInfo!
    totalCount: Int!
}

type EventTypeEdge {
    node: EventType!
    cursor: String!
}

type EventConnection {
    edges: [EventEdge!]!
    pageInfo: PageInfo!
    totalCount: Int!
}

type EventEdge {
    node: Event!
    cursor: String!
}

type EndpointConnection {
    edges: [EndpointEdge!]!
    pageInfo: PageInfo!
    totalCount: Int!
}

type EndpointEdge {
    node: Endpoint!
    cursor: String!
}

type PageInfo {
    hasNextPage: Boolean!
    hasPreviousPage: Boolean!
    startCursor: String
    endCursor: String
}

type QueueStats {
    queued: Int!
    delivering: Int!
    delivered: Int!
    failed: Int!
    dead: Int!
    pending: Int!
    processing: Int!
    delayed: Int!
}

# Priority queue statistics
type PriorityQueueStats {
    # Number of events in high priority queue (priority 1-3)
    high: Int!
    # Number of events in normal priority queue (priority 4-7)
    normal: Int!
    # Number of events in low priority queue (priority 8-10)
    low: Int!
    # Number of events in delayed queue (scheduled for future)
    delayed: Int!
}

type BatchRetryResult {
    succeeded: [Event!]!
    failed: [BatchRetryError!]!
    totalRequested: Int!
    totalSucceeded: Int!
}

type BatchRetryError {
    eventId: ID!
    error: String!
}

enum EventStatus {
    QUEUED
    DELIVERING
    DELIVERED
    FAILED
    DEAD
}

enum EndpointStatus {
    ACTIVE
    PAUSED
    DISABLED
}

# Legacy input: direct destination URL
input CreateEventInput {
    destination: String!
    payload: JSON!
    headers: JSON
    maxAttempts: Int
    # Priority: 1-10 (1=highest, 10=lowest, default=5)
    priority: Int
    # Schedule for future delivery (absolute time)
    deliverAt: DateTime
    # Schedule for future delivery (relative delay in seconds)
    delaySeconds: Int
}

# New input: event type based routing
input SendEventInput {
    eventType: String!
    payload: JSON!
    headers: JSON
    # Priority: 1-10 (1=highest, 10=lowest, default=5)
    priority: Int
    # Schedule for future delivery (absolute time)
    deliverAt: DateTime
    # Schedule for future delivery (relative delay in seconds)
    delaySeconds: Int
}

input CreateEndpointInput {
    url: String!
    description: String
    eventTypes: [String!]!

    # Content-based routing filter (optional)
    # JSON object with filter rules using JSONPath expressions
    # Example: {"rule": {"path": "$.data.amount", "operator": "gt", "value": 100}}
    filter: JSON

    # Payload transformation (optional)
    # JavaScript code to transform webhook before delivery
    # Example: function transform(webhook) { return { ...webhook, payload: { wrapped: webhook.payload } }; }
    transformation: String

    # FIFO (ordered delivery) configuration
    # When true, events are delivered sequentially - one at a time
    fifo: Boolean
    # JSONPath expression to extract partition key from payload
    # Example: "$.customer_id" or "$.data.order_id"
    fifoPartitionKey: String

    # Optional configuration (uses defaults if not provided)
    maxRetries: Int
    retryBackoffMs: Int
    retryBackoffMax: Int
    retryBackoffMult: Float
    timeoutMs: Int
    rateLimitPerSec: Int
    circuitThreshold: Int
    circuitResetMs: Int
    customHeaders: JSON
}

input UpdateEndpointInput {
    url: String
    description: String
    eventTypes: [String!]
    status: EndpointStatus

    # Content-based routing filter (set to null to remove)
    filter: JSON

    # Payload transformation (set to null to remove)
    transformation: String

    # FIFO (ordered delivery) configuration
    fifo: Boolean
    fifoPartitionKey: String

    maxRetries: Int
    retryBackoffMs: Int
    retryBackoffMax: Int
    retryBackoffMult: Float
    timeoutMs: Int
    rateLimitPerSec: Int
    circuitThreshold: Int
    circuitResetMs: Int
    customHeaders: JSON
}

input CreateEventTypeInput {
    name: String!
    description: String
    schema: JSON
    schemaVersion: String
}

input UpdateEventTypeInput {
    description: String
    schema: JSON
    schemaVersion: String
}

# FIFO Queue Management Types

type FIFOQueueStats {
    endpointId: ID!
    partitionKey: String!
    queueLength: Int!
    isLocked: Boolean!
    hasInFlight: Boolean!
}

type FIFOEndpointStats {
    endpointId: ID!
    totalPartitions: Int!
    totalQueuedMessages: Int!
    partitions: [FIFOQueueStats!]!
}

type FIFODrainResult {
    endpointId: ID!
    partitionKey: String
    messagesDrained: Int!
    movedToStandard: Boolean!
}

type FIFORecoveryResult {
    messagesRecovered: Int!
}

# Extend Query with FIFO management and priority queue stats
extend type Query {
    # Get FIFO queue stats for a specific endpoint
    fifoQueueStats(endpointId: ID!): FIFOEndpointStats
    
    # Get FIFO queue stats for a specific partition
    fifoPartitionStats(endpointId: ID!, partitionKey: String!): FIFOQueueStats
    
    # List all active FIFO queues
    activeFIFOQueues: [FIFOQueueStats!]!
    
    # Get priority queue statistics
    priorityQueueStats: PriorityQueueStats!
}

# Extend Mutation with FIFO management and scheduled event operations
extend type Mutation {
    # Forcibly release a stuck FIFO lock (admin operation)
    releaseFIFOLock(endpointId: ID!, partitionKey: String): Boolean!
    
    # Drain a FIFO queue and optionally move messages to standard queue
    drainFIFOQueue(endpointId: ID!, partitionKey: String, moveToStandard: Boolean): FIFODrainResult!
    
    # Recover all stale in-flight FIFO messages (admin operation)
    recoverStaleFIFOMessages: FIFORecoveryResult!
    
    # Cancel a scheduled event before it is delivered
    # Only works for events that are still in QUEUED status with a future scheduledAt
    cancelScheduledEvent(id: ID!): Event!
}

# ==========================================
# Analytics Types
# ==========================================

# Aggregated statistics for a time period
type AnalyticsStats {
    period: String!
    totalCount: Int!
    successCount: Int!
    failureCount: Int!
    timeoutCount: Int!
    successRate: Float!
    failureRate: Float!
    avgLatencyMs: Float!
    p50LatencyMs: Float!
    p95LatencyMs: Float!
    p99LatencyMs: Float!
    minLatencyMs: Int!
    maxLatencyMs: Int!
}

# A single point in a time series
type TimeSeriesPoint {
    timestamp: DateTime!
    value: Float!
}

# Breakdown item for analytics by dimension
type BreakdownItem {
    key: String!
    count: Int!
    successRate: Float!
    avgLatencyMs: Float!
}

# Time granularity for analytics queries
enum TimeGranularity {
    MINUTE
    HOUR
    DAY
    WEEK
}

# Analytics input for time range queries
input AnalyticsTimeRange {
    start: DateTime!
    end: DateTime!
}

# Extend Query with analytics
extend type Query {
    # Get aggregated delivery statistics for a time range
    analyticsStats(timeRange: AnalyticsTimeRange!): AnalyticsStats!
    
    # Get success rate time series with specified granularity
    successRateTimeSeries(
        timeRange: AnalyticsTimeRange!
        granularity: TimeGranularity!
    ): [TimeSeriesPoint!]!
    
    # Get latency time series (average) with specified granularity
    latencyTimeSeries(
        timeRange: AnalyticsTimeRange!
        granularity: TimeGranularity!
    ): [TimeSeriesPoint!]!
    
    # Get delivery count time series with specified granularity
    deliveryCountTimeSeries(
        timeRange: AnalyticsTimeRange!
        granularity: TimeGranularity!
    ): [TimeSeriesPoint!]!
    
    # Get breakdown by event type
    breakdownByEventType(
        timeRange: AnalyticsTimeRange!
        limit: Int
    ): [BreakdownItem!]!
    
    # Get breakdown by endpoint
    breakdownByEndpoint(
        timeRange: AnalyticsTimeRange!
        limit: Int
    ): [BreakdownItem!]!
    
    # Get breakdown by status (success/failure/timeout)
    breakdownByStatus(timeRange: AnalyticsTimeRange!): [BreakdownItem!]!
    
    # Get latency percentiles for a time range
    latencyPercentiles(timeRange: AnalyticsTimeRange!): LatencyPercentiles!
    
    # Get analytics for a specific endpoint
    endpointAnalytics(
        endpointId: ID!
        timeRange: AnalyticsTimeRange!
    ): AnalyticsStats!
    
    # Get analytics for a specific event type
    eventTypeAnalytics(
        eventType: String!
        timeRange: AnalyticsTimeRange!
    ): AnalyticsStats!
}

# Latency percentiles
type LatencyPercentiles {
    p50: Float!
    p95: Float!
    p99: Float!
}

# ==========================================
# Alerting Types
# ==========================================

# Alert rule for monitoring webhook delivery
type AlertRule {
    id: ID!
    name: String!
    description: String
    enabled: Boolean!
    condition: AlertCondition!
    action: AlertAction!
    cooldown: String!
    lastFiredAt: DateTime
    createdAt: DateTime!
    updatedAt: DateTime!
}

# Condition that triggers an alert
type AlertCondition {
    metric: AlertMetric!
    operator: AlertOperator!
    value: Float!
    window: String!
}

# Action to take when alert fires
type AlertAction {
    type: AlertActionType!
    webhookUrl: String
    channel: String
    to: [String!]
    subject: String
    routingKey: String
    severity: String
    message: String
}

# Alert that has been fired
type Alert {
    id: ID!
    ruleId: ID!
    ruleName: String!
    metric: String!
    value: Float!
    threshold: Float!
    message: String!
    firedAt: DateTime!
}

# Metrics that can trigger alerts
enum AlertMetric {
    FAILURE_RATE
    SUCCESS_RATE
    LATENCY
    QUEUE_DEPTH
    ERROR_COUNT
    DELIVERY_COUNT
}

# Comparison operators for alert conditions
enum AlertOperator {
    GT
    GTE
    LT
    LTE
    EQ
    NE
}

# Types of alert actions
enum AlertActionType {
    SLACK
    EMAIL
    WEBHOOK
    PAGERDUTY
}

# Input for creating/updating alert rules
input CreateAlertRuleInput {
    name: String!
    description: String
    condition: AlertConditionInput!
    action: AlertActionInput!
    cooldown: String
}

input UpdateAlertRuleInput {
    name: String
    description: String
    enabled: Boolean
    condition: AlertConditionInput
    action: AlertActionInput
    cooldown: String
}

input AlertConditionInput {
    metric: AlertMetric!
    operator: AlertOperator!
    value: Float!
    window: String!
}

input AlertActionInput {
    type: AlertActionType!
    webhookUrl: String
    channel: String
    to: [String!]
    subject: String
    routingKey: String
    severity: String
    message: String
}

# Extend Query with alerting
extend type Query {
    # Get a specific alert rule
    alertRule(id: ID!): AlertRule
    
    # List all alert rules
    alertRules: [AlertRule!]!
    
    # Get alert history
    alertHistory(limit: Int): [Alert!]!
}

# Extend Mutation with alerting
extend type Mutation {
    # Create a new alert rule
    createAlertRule(input: CreateAlertRuleInput!): AlertRule!
    
    # Update an existing alert rule
    updateAlertRule(id: ID!, input: UpdateAlertRuleInput!): AlertRule!
    
    # Delete an alert rule
    deleteAlertRule(id: ID!): Boolean!
    
    # Enable an alert rule
    enableAlertRule(id: ID!): AlertRule!
    
    # Disable an alert rule
    disableAlertRule(id: ID!): AlertRule!
    
    # Manually trigger evaluation of all alert rules (for testing)
    evaluateAlertRules: Boolean!
}

# =============================================================================
# Connector Types - Pre-built integrations for common services
# =============================================================================

enum ConnectorType {
    SLACK
    DISCORD
    TEAMS
    EMAIL
    WEBHOOK
}

type Connector {
    name: String!
    type: ConnectorType!
    config: ConnectorConfig!
    template: ConnectorTemplate!
}

type ConnectorConfig {
    webhookUrl: String
    channel: String
    username: String
    iconEmoji: String
    iconUrl: String
    smtpHost: String
    smtpPort: Int
    fromEmail: String
    toEmails: [String!]
}

type ConnectorTemplate {
    text: String
    title: String
    body: String
    color: String
    subject: String
}

input ConnectorConfigInput {
    webhookUrl: String
    channel: String
    username: String
    iconEmoji: String
    iconUrl: String
    smtpHost: String
    smtpPort: Int
    smtpUsername: String
    smtpPassword: String
    fromEmail: String
    toEmails: [String!]
}

input ConnectorTemplateInput {
    text: String
    title: String
    body: String
    color: String
    subject: String
}

input CreateConnectorInput {
    name: String!
    type: ConnectorType!
    config: ConnectorConfigInput!
    template: ConnectorTemplateInput
}

input UpdateConnectorInput {
    config: ConnectorConfigInput
    template: ConnectorTemplateInput
}

# Extend Query with connectors
extend type Query {
    # Get a connector by name
    connector(name: String!): Connector
    
    # List all registered connectors
    connectors: [Connector!]!
}

# Extend Mutation with connectors
extend type Mutation {
    # Register a new connector
    createConnector(input: CreateConnectorInput!): Connector!
    
    # Update a connector
    updateConnector(name: String!, input: UpdateConnectorInput!): Connector!
    
    # Delete a connector
    deleteConnector(name: String!): Boolean!
}
