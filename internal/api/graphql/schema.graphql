scalar JSON
scalar DateTime

type Query {
    event(id: ID!): Event
    events(status: EventStatus, first: Int, after: String): EventConnection!
    queueStats: QueueStats!

    # Endpoint queries
    endpoint(id: ID!): Endpoint
    endpoints(
        status: EndpointStatus
        first: Int
        after: String
    ): EndpointConnection!

    # Event type queries
    eventType(id: ID!): EventType
    eventTypeByName(name: String!): EventType
    eventTypes(first: Int, after: String): EventTypeConnection!
}

type Mutation {
    # Legacy: create event with direct destination URL
    createEvent(input: CreateEventInput!, idempotencyKey: String!): Event!

    # New: create event by event type (fans out to all subscribed endpoints)
    sendEvent(input: SendEventInput!, idempotencyKey: String!): [Event!]!

    replayEvent(id: ID!): Event!

    # Batch retry operations
    retryEvents(ids: [ID!]!): BatchRetryResult!
    retryEventsByStatus(status: EventStatus!, limit: Int): BatchRetryResult!
    retryEventsByEndpoint(
        endpointId: ID!
        status: EventStatus
        limit: Int
    ): BatchRetryResult!

    # Endpoint mutations
    createEndpoint(input: CreateEndpointInput!): Endpoint!
    updateEndpoint(id: ID!, input: UpdateEndpointInput!): Endpoint!
    deleteEndpoint(id: ID!): Boolean!
    pauseEndpoint(id: ID!): Endpoint!
    resumeEndpoint(id: ID!): Endpoint!

    # Secret rotation mutations
    rotateEndpointSecret(id: ID!): EndpointSecretRotation!
    clearPreviousSecret(id: ID!): Endpoint!

    # Event type mutations
    createEventType(input: CreateEventTypeInput!): EventType!
    updateEventType(id: ID!, input: UpdateEventTypeInput!): EventType!
    deleteEventType(id: ID!): Boolean!

    # Transformation testing
    testTransformation(input: TestTransformationInput!): TransformationTestResult!
}

# Transformation testing types
input TestTransformationInput {
    code: String!
    webhook: WebhookInput!
}

input WebhookInput {
    method: String
    url: String!
    headers: JSON
    payload: JSON!
}

type TransformationTestResult {
    success: Boolean!
    result: TransformationResult
    error: String
    executionMs: Int!
}

type TransformationResult {
    method: String!
    url: String!
    headers: JSON
    payload: JSON
    cancel: Boolean!
}

type EndpointSecretRotation {
    endpoint: Endpoint!
    newSecret: String!
}

type Event {
    id: ID!
    idempotencyKey: String!
    clientId: String
    eventType: String
    endpointId: ID
    destination: String!
    payload: JSON!
    headers: JSON
    status: EventStatus!
    priority: Int!
    scheduledAt: DateTime
    attempts: Int!
    maxAttempts: Int!
    nextAttemptAt: DateTime
    deliveredAt: DateTime
    createdAt: DateTime!
    updatedAt: DateTime!
    deliveryAttempts: [DeliveryAttempt!]!

    # Resolved fields
    endpoint: Endpoint
}

type DeliveryAttempt {
    id: ID!
    eventId: ID!
    statusCode: Int
    responseBody: String
    error: String
    durationMs: Int!
    attemptNumber: Int!
    attemptedAt: DateTime!
}

type Endpoint {
    id: ID!
    clientId: String!
    url: String!
    description: String
    eventTypes: [String!]!
    status: EndpointStatus!

    # Content-based routing filter (optional)
    # If set, events are only delivered if they match the filter conditions
    filter: JSON

    # Payload transformation (optional)
    # JavaScript code to transform webhook payload before delivery
    transformation: String

    # FIFO (ordered delivery) configuration
    # When enabled, events are delivered sequentially - one at a time
    fifo: Boolean!
    # JSONPath expression to extract partition key from payload
    # Events with same partition key are delivered in order
    # Different partition keys can be processed in parallel
    fifoPartitionKey: String

    # Retry configuration
    maxRetries: Int!
    retryBackoffMs: Int!
    retryBackoffMax: Int!
    retryBackoffMult: Float!

    # Delivery configuration
    timeoutMs: Int!
    rateLimitPerSec: Int!

    # Circuit breaker configuration
    circuitThreshold: Int!
    circuitResetMs: Int!

    customHeaders: JSON

    # Secret rotation (secrets are not exposed, only metadata)
    hasCustomSecret: Boolean!
    secretRotatedAt: DateTime

    createdAt: DateTime!
    updatedAt: DateTime!

    # Computed fields
    stats: EndpointStats!
    recentEvents(first: Int): [Event!]!
}

type EndpointStats {
    totalEvents: Int!
    delivered: Int!
    failed: Int!
    pending: Int!
    successRate: Float!
    avgLatencyMs: Float!
}

type EventType {
    id: ID!
    clientId: String!
    name: String!
    description: String
    schema: JSON
    schemaVersion: String
    createdAt: DateTime!
    updatedAt: DateTime!
}

type EventTypeConnection {
    edges: [EventTypeEdge!]!
    pageInfo: PageInfo!
    totalCount: Int!
}

type EventTypeEdge {
    node: EventType!
    cursor: String!
}

type EventConnection {
    edges: [EventEdge!]!
    pageInfo: PageInfo!
    totalCount: Int!
}

type EventEdge {
    node: Event!
    cursor: String!
}

type EndpointConnection {
    edges: [EndpointEdge!]!
    pageInfo: PageInfo!
    totalCount: Int!
}

type EndpointEdge {
    node: Endpoint!
    cursor: String!
}

type PageInfo {
    hasNextPage: Boolean!
    hasPreviousPage: Boolean!
    startCursor: String
    endCursor: String
}

type QueueStats {
    queued: Int!
    delivering: Int!
    delivered: Int!
    failed: Int!
    dead: Int!
    pending: Int!
    processing: Int!
    delayed: Int!
}

# Priority queue statistics
type PriorityQueueStats {
    # Number of events in high priority queue (priority 1-3)
    high: Int!
    # Number of events in normal priority queue (priority 4-7)
    normal: Int!
    # Number of events in low priority queue (priority 8-10)
    low: Int!
    # Number of events in delayed queue (scheduled for future)
    delayed: Int!
}

type BatchRetryResult {
    succeeded: [Event!]!
    failed: [BatchRetryError!]!
    totalRequested: Int!
    totalSucceeded: Int!
}

type BatchRetryError {
    eventId: ID!
    error: String!
}

enum EventStatus {
    QUEUED
    DELIVERING
    DELIVERED
    FAILED
    DEAD
}

enum EndpointStatus {
    ACTIVE
    PAUSED
    DISABLED
}

# Legacy input: direct destination URL
input CreateEventInput {
    destination: String!
    payload: JSON!
    headers: JSON
    maxAttempts: Int
    # Priority: 1-10 (1=highest, 10=lowest, default=5)
    priority: Int
    # Schedule for future delivery (absolute time)
    deliverAt: DateTime
    # Schedule for future delivery (relative delay in seconds)
    delaySeconds: Int
}

# New input: event type based routing
input SendEventInput {
    eventType: String!
    payload: JSON!
    headers: JSON
    # Priority: 1-10 (1=highest, 10=lowest, default=5)
    priority: Int
    # Schedule for future delivery (absolute time)
    deliverAt: DateTime
    # Schedule for future delivery (relative delay in seconds)
    delaySeconds: Int
}

input CreateEndpointInput {
    url: String!
    description: String
    eventTypes: [String!]!

    # Content-based routing filter (optional)
    # JSON object with filter rules using JSONPath expressions
    # Example: {"rule": {"path": "$.data.amount", "operator": "gt", "value": 100}}
    filter: JSON

    # Payload transformation (optional)
    # JavaScript code to transform webhook before delivery
    # Example: function transform(webhook) { return { ...webhook, payload: { wrapped: webhook.payload } }; }
    transformation: String

    # FIFO (ordered delivery) configuration
    # When true, events are delivered sequentially - one at a time
    fifo: Boolean
    # JSONPath expression to extract partition key from payload
    # Example: "$.customer_id" or "$.data.order_id"
    fifoPartitionKey: String

    # Optional configuration (uses defaults if not provided)
    maxRetries: Int
    retryBackoffMs: Int
    retryBackoffMax: Int
    retryBackoffMult: Float
    timeoutMs: Int
    rateLimitPerSec: Int
    circuitThreshold: Int
    circuitResetMs: Int
    customHeaders: JSON
}

input UpdateEndpointInput {
    url: String
    description: String
    eventTypes: [String!]
    status: EndpointStatus

    # Content-based routing filter (set to null to remove)
    filter: JSON

    # Payload transformation (set to null to remove)
    transformation: String

    # FIFO (ordered delivery) configuration
    fifo: Boolean
    fifoPartitionKey: String

    maxRetries: Int
    retryBackoffMs: Int
    retryBackoffMax: Int
    retryBackoffMult: Float
    timeoutMs: Int
    rateLimitPerSec: Int
    circuitThreshold: Int
    circuitResetMs: Int
    customHeaders: JSON
}

input CreateEventTypeInput {
    name: String!
    description: String
    schema: JSON
    schemaVersion: String
}

input UpdateEventTypeInput {
    description: String
    schema: JSON
    schemaVersion: String
}

# FIFO Queue Management Types

type FIFOQueueStats {
    endpointId: ID!
    partitionKey: String!
    queueLength: Int!
    isLocked: Boolean!
    hasInFlight: Boolean!
}

type FIFOEndpointStats {
    endpointId: ID!
    totalPartitions: Int!
    totalQueuedMessages: Int!
    partitions: [FIFOQueueStats!]!
}

type FIFODrainResult {
    endpointId: ID!
    partitionKey: String
    messagesDrained: Int!
    movedToStandard: Boolean!
}

type FIFORecoveryResult {
    messagesRecovered: Int!
}

# Extend Query with FIFO management and priority queue stats
extend type Query {
    # Get FIFO queue stats for a specific endpoint
    fifoQueueStats(endpointId: ID!): FIFOEndpointStats
    
    # Get FIFO queue stats for a specific partition
    fifoPartitionStats(endpointId: ID!, partitionKey: String!): FIFOQueueStats
    
    # List all active FIFO queues
    activeFIFOQueues: [FIFOQueueStats!]!
    
    # Get priority queue statistics
    priorityQueueStats: PriorityQueueStats!
}

# Extend Mutation with FIFO management and scheduled event operations
extend type Mutation {
    # Forcibly release a stuck FIFO lock (admin operation)
    releaseFIFOLock(endpointId: ID!, partitionKey: String): Boolean!
    
    # Drain a FIFO queue and optionally move messages to standard queue
    drainFIFOQueue(endpointId: ID!, partitionKey: String, moveToStandard: Boolean): FIFODrainResult!
    
    # Recover all stale in-flight FIFO messages (admin operation)
    recoverStaleFIFOMessages: FIFORecoveryResult!
    
    # Cancel a scheduled event before it is delivered
    # Only works for events that are still in QUEUED status with a future scheduledAt
    cancelScheduledEvent(id: ID!): Event!
}
