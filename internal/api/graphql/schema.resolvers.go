package graphql

// This file will be automatically regenerated based on the schema, any resolver
// implementations will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.86

import (
	"context"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"strconv"

	"github.com/google/uuid"
	"github.com/relay/internal/config"
	"github.com/relay/internal/domain"
)

// DeliveryAttempts is the resolver for the deliveryAttempts field.
func (r *eventResolver) DeliveryAttempts(ctx context.Context, obj *Event) ([]DeliveryAttempt, error) {
	uid, err := uuid.Parse(obj.ID)
	if err != nil {
		return nil, fmt.Errorf("invalid event ID: %w", err)
	}

	attempts, err := r.Store.GetDeliveryAttempts(ctx, uid)
	if err != nil {
		return nil, err
	}

	result := make([]DeliveryAttempt, len(attempts))
	for i, a := range attempts {
		result[i] = domainAttemptToGQL(a)
	}
	return result, nil
}

// CreateEvent is the resolver for the createEvent field.
func (r *mutationResolver) CreateEvent(ctx context.Context, input CreateEventInput, idempotencyKey string) (*Event, error) {
	// Validate idempotency key
	if err := config.ValidateIdempotencyKey(idempotencyKey); err != nil {
		return nil, err
	}

	// Validate destination URL (SSRF protection)
	if err := config.ValidateDestinationURL(input.Destination); err != nil {
		return nil, fmt.Errorf("invalid destination: %w", err)
	}

	// Marshal and validate payload size
	payload, err := json.Marshal(input.Payload)
	if err != nil {
		return nil, fmt.Errorf("invalid payload: %w", err)
	}
	if err := config.ValidatePayloadSize(payload); err != nil {
		return nil, err
	}

	// Check idempotency
	existingID, err := r.Dedup.CheckAndSet(ctx, idempotencyKey, uuid.Nil)
	if err != nil {
		return nil, err
	}

	if existingID != uuid.Nil {
		evt, err := r.Store.GetByID(ctx, existingID)
		if err != nil {
			return nil, err
		}
		return domainEventToGQL(evt), nil
	}

	// Parse headers
	var headers map[string]string
	if input.Headers != nil {
		headers = make(map[string]string)
		for k, v := range input.Headers {
			if s, ok := v.(string); ok {
				headers[k] = s
			}
		}
	}

	// Create event
	evt := domain.NewEvent(idempotencyKey, input.Destination, payload, headers)
	if input.MaxAttempts != nil && *input.MaxAttempts > 0 {
		evt.MaxAttempts = *input.MaxAttempts
	}

	// Save to store
	evt, err = r.Store.Create(ctx, evt)
	if err != nil {
		_ = r.Dedup.Delete(ctx, idempotencyKey)
		return nil, err
	}

	// Update idempotency key with actual event ID
	_ = r.Dedup.Set(ctx, idempotencyKey, evt.ID)

	// Enqueue for delivery
	if err := r.Queue.Enqueue(ctx, evt.ID); err != nil {
		return nil, fmt.Errorf("failed to enqueue event: %w", err)
	}

	return domainEventToGQL(evt), nil
}

// ReplayEvent is the resolver for the replayEvent field.
func (r *mutationResolver) ReplayEvent(ctx context.Context, id string) (*Event, error) {
	uid, err := uuid.Parse(id)
	if err != nil {
		return nil, fmt.Errorf("invalid event ID: %w", err)
	}

	evt, err := r.Store.GetByID(ctx, uid)
	if err != nil {
		return nil, err
	}

	if evt.Status != domain.EventStatusDead && evt.Status != domain.EventStatusFailed {
		return nil, fmt.Errorf("can only replay dead or failed events")
	}

	// Use domain method for immutability
	evt = evt.Replay()

	evt, err = r.Store.Update(ctx, evt)
	if err != nil {
		return nil, err
	}

	if err := r.Queue.Enqueue(ctx, evt.ID); err != nil {
		return nil, fmt.Errorf("failed to enqueue event: %w", err)
	}

	return domainEventToGQL(evt), nil
}

// Event is the resolver for the event field.
func (r *queryResolver) Event(ctx context.Context, id string) (*Event, error) {
	uid, err := uuid.Parse(id)
	if err != nil {
		return nil, fmt.Errorf("invalid event ID: %w", err)
	}

	evt, err := r.Store.GetByID(ctx, uid)
	if err != nil {
		return nil, err
	}

	return domainEventToGQL(evt), nil
}

// Events is the resolver for the events field.
func (r *queryResolver) Events(ctx context.Context, status *EventStatus, first *int, after *string) (*EventConnection, error) {
	limit := 20
	if first != nil && *first > 0 {
		limit = *first
		if limit > 100 {
			limit = 100
		}
	}

	offset := 0
	if after != nil {
		decoded, err := base64.StdEncoding.DecodeString(*after)
		if err == nil {
			offset, _ = strconv.Atoi(string(decoded))
		}
	}

	var events []domain.Event
	var err error

	if status != nil {
		events, err = r.Store.ListByStatus(ctx, gqlStatusToDomain(*status), limit+1, offset)
	} else {
		events, err = r.Store.ListReadyForDelivery(ctx, limit+1)
	}
	if err != nil {
		return nil, err
	}

	hasNextPage := len(events) > limit
	if hasNextPage {
		events = events[:limit]
	}

	edges := make([]EventEdge, len(events))
	for i, evt := range events {
		cursor := base64.StdEncoding.EncodeToString([]byte(strconv.Itoa(offset + i + 1)))
		edges[i] = EventEdge{
			Node:   domainEventToGQL(evt),
			Cursor: cursor,
		}
	}

	var startCursor, endCursor *string
	if len(edges) > 0 {
		startCursor = &edges[0].Cursor
		endCursor = &edges[len(edges)-1].Cursor
	}

	return &EventConnection{
		Edges: edges,
		PageInfo: &PageInfo{
			HasNextPage:     hasNextPage,
			HasPreviousPage: offset > 0,
			StartCursor:     startCursor,
			EndCursor:       endCursor,
		},
		TotalCount: len(events),
	}, nil
}

// QueueStats is the resolver for the queueStats field.
func (r *queryResolver) QueueStats(ctx context.Context) (*QueueStats, error) {
	dbStats, err := r.Store.GetQueueStats(ctx)
	if err != nil {
		return nil, err
	}

	queueStats, err := r.Queue.Stats(ctx)
	if err != nil {
		return nil, err
	}

	return &QueueStats{
		Queued:     int(dbStats.Queued),
		Delivering: int(dbStats.Delivering),
		Delivered:  int(dbStats.Delivered),
		Failed:     int(dbStats.Failed),
		Dead:       int(dbStats.Dead),
		Pending:    int(queueStats.Pending),
		Processing: int(queueStats.Processing),
		Delayed:    int(queueStats.Delayed),
	}, nil
}

// Event returns EventResolver implementation.
func (r *Resolver) Event() EventResolver { return &eventResolver{r} }

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type eventResolver struct{ *Resolver }
type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }

// Helper functions

func domainEventToGQL(evt domain.Event) *Event {
	var payload map[string]any
	if len(evt.Payload) > 0 {
		json.Unmarshal(evt.Payload, &payload)
	}

	var headers map[string]any
	if len(evt.Headers) > 0 {
		headers = make(map[string]any)
		for k, v := range evt.Headers {
			headers[k] = v
		}
	}

	return &Event{
		ID:             evt.ID.String(),
		IdempotencyKey: evt.IdempotencyKey,
		Destination:    evt.Destination,
		Payload:        payload,
		Headers:        headers,
		Status:         domainStatusToGQL(evt.Status),
		Attempts:       evt.Attempts,
		MaxAttempts:    evt.MaxAttempts,
		NextAttemptAt:  evt.NextAttemptAt,
		DeliveredAt:    evt.DeliveredAt,
		CreatedAt:      evt.CreatedAt,
		UpdatedAt:      evt.UpdatedAt,
	}
}

func domainAttemptToGQL(a domain.DeliveryAttempt) DeliveryAttempt {
	result := DeliveryAttempt{
		ID:            a.ID.String(),
		EventID:       a.EventID.String(),
		DurationMs:    int(a.DurationMs),
		AttemptNumber: a.AttemptNumber,
		AttemptedAt:   a.AttemptedAt,
	}

	if a.StatusCode != 0 {
		sc := a.StatusCode
		result.StatusCode = &sc
	}

	if a.ResponseBody != "" {
		result.ResponseBody = &a.ResponseBody
	}

	if a.Error != "" {
		result.Error = &a.Error
	}

	return result
}

func domainStatusToGQL(s domain.EventStatus) EventStatus {
	switch s {
	case domain.EventStatusQueued:
		return EventStatusQueued
	case domain.EventStatusDelivering:
		return EventStatusDelivering
	case domain.EventStatusDelivered:
		return EventStatusDelivered
	case domain.EventStatusFailed:
		return EventStatusFailed
	case domain.EventStatusDead:
		return EventStatusDead
	default:
		return EventStatusQueued
	}
}

func gqlStatusToDomain(s EventStatus) domain.EventStatus {
	switch s {
	case EventStatusQueued:
		return domain.EventStatusQueued
	case EventStatusDelivering:
		return domain.EventStatusDelivering
	case EventStatusDelivered:
		return domain.EventStatusDelivered
	case EventStatusFailed:
		return domain.EventStatusFailed
	case EventStatusDead:
		return domain.EventStatusDead
	default:
		return domain.EventStatusQueued
	}
}
