package graphql

// This file will be automatically regenerated based on the schema, any resolver
// implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.86

import (
	"context"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"strconv"
	"time"

	"github.com/google/uuid"
	"github.com/stiffinWanjohi/relay/internal/alerting"
	"github.com/stiffinWanjohi/relay/internal/auth"
	"github.com/stiffinWanjohi/relay/internal/config"
	"github.com/stiffinWanjohi/relay/internal/connector"
	"github.com/stiffinWanjohi/relay/internal/domain"
	"github.com/stiffinWanjohi/relay/internal/queue"
)

// Stats is the resolver for the stats field.
func (r *endpointResolver) Stats(ctx context.Context, obj *Endpoint) (*EndpointStats, error) {
	uid, err := uuid.Parse(obj.ID)
	if err != nil {
		return nil, fmt.Errorf("invalid endpoint ID: %w", err)
	}

	stats, err := r.Store.GetEndpointStats(ctx, uid)
	if err != nil {
		return nil, err
	}

	return &EndpointStats{
		TotalEvents:  int(stats.TotalEvents),
		Delivered:    int(stats.Delivered),
		Failed:       int(stats.Failed),
		Pending:      int(stats.Pending),
		SuccessRate:  stats.SuccessRate,
		AvgLatencyMs: stats.AvgLatencyMs,
	}, nil
}

// RecentEvents is the resolver for the recentEvents field.
func (r *endpointResolver) RecentEvents(ctx context.Context, obj *Endpoint, first *int) ([]Event, error) {
	uid, err := uuid.Parse(obj.ID)
	if err != nil {
		return nil, fmt.Errorf("invalid endpoint ID: %w", err)
	}

	limit := 10
	if first != nil && *first > 0 {
		limit = *first
		if limit > 100 {
			limit = 100
		}
	}

	events, err := r.Store.ListEventsByEndpoint(ctx, uid, limit, 0)
	if err != nil {
		return nil, err
	}

	result := make([]Event, len(events))
	for i, evt := range events {
		result[i] = *domainEventToGQL(evt)
	}
	return result, nil
}

// DeliveryAttempts is the resolver for the deliveryAttempts field.
func (r *eventResolver) DeliveryAttempts(ctx context.Context, obj *Event) ([]DeliveryAttempt, error) {
	uid, err := uuid.Parse(obj.ID)
	if err != nil {
		return nil, fmt.Errorf("invalid event ID: %w", err)
	}

	attempts, err := r.Store.GetDeliveryAttempts(ctx, uid)
	if err != nil {
		return nil, err
	}

	result := make([]DeliveryAttempt, len(attempts))
	for i, a := range attempts {
		result[i] = domainAttemptToGQL(a)
	}
	return result, nil
}

// Endpoint is the resolver for the endpoint field.
func (r *eventResolver) Endpoint(ctx context.Context, obj *Event) (*Endpoint, error) {
	if obj.EndpointID == nil {
		return nil, nil
	}

	uid, err := uuid.Parse(*obj.EndpointID)
	if err != nil {
		return nil, fmt.Errorf("invalid endpoint ID: %w", err)
	}

	endpoint, err := r.Store.GetEndpointByID(ctx, uid)
	if err != nil {
		return nil, err
	}

	return domainEndpointToGQL(endpoint), nil
}

// CreateEvent is the resolver for the createEvent field.
func (r *mutationResolver) CreateEvent(ctx context.Context, input CreateEventInput, idempotencyKey string) (*Event, error) {
	// Validate idempotency key
	if err := config.ValidateIdempotencyKey(idempotencyKey); err != nil {
		return nil, err
	}

	// Validate destination URL (SSRF protection)
	if err := config.ValidateDestinationURL(input.Destination); err != nil {
		return nil, fmt.Errorf("invalid destination: %w", err)
	}

	// Marshal and validate payload size
	payload, err := json.Marshal(input.Payload)
	if err != nil {
		return nil, fmt.Errorf("invalid payload: %w", err)
	}
	if err := config.ValidatePayloadSize(payload); err != nil {
		return nil, err
	}

	// Validate and compute scheduling
	scheduledAt, err := validateScheduling(input.DeliverAt, input.DelaySeconds)
	if err != nil {
		return nil, err
	}

	// Validate priority
	priority := domain.DefaultPriority
	if input.Priority != nil {
		if *input.Priority < 1 || *input.Priority > 10 {
			return nil, fmt.Errorf("priority must be between 1 and 10")
		}
		priority = *input.Priority
	}

	// Parse headers first (needed for event creation)
	var headers map[string]string
	if input.Headers != nil {
		headers = make(map[string]string)
		for k, v := range input.Headers {
			if s, ok := v.(string); ok {
				headers[k] = s
			}
		}
	}

	// Create event object with a new ID (not yet persisted)
	evt := domain.NewEventWithOptions(idempotencyKey, input.Destination, payload, headers, priority, scheduledAt)
	if input.MaxAttempts != nil && *input.MaxAttempts > 0 {
		evt.MaxAttempts = *input.MaxAttempts
	}

	// Check idempotency - use the real event ID we just generated
	existingID, err := r.Dedup.CheckAndSet(ctx, idempotencyKey, evt.ID)
	if err != nil {
		return nil, err
	}

	// If another request already processed this idempotency key, return that event
	if existingID != uuid.Nil {
		existingEvt, err := r.Store.GetByID(ctx, existingID)
		if err != nil {
			return nil, err
		}
		return domainEventToGQL(existingEvt), nil
	}

	// We won the race - save the event to store with outbox entry
	evt, err = r.Store.CreateWithOutbox(ctx, evt)
	if err != nil {
		_ = r.Dedup.Delete(ctx, idempotencyKey)
		return nil, err
	}

	return domainEventToGQL(evt), nil
}

// SendEvent is the resolver for the sendEvent field.
func (r *mutationResolver) SendEvent(ctx context.Context, input SendEventInput, idempotencyKey string) ([]Event, error) {
	clientID, err := auth.RequireClientID(ctx)
	if err != nil {
		return nil, err
	}

	// Validate idempotency key
	if err := config.ValidateIdempotencyKey(idempotencyKey); err != nil {
		return nil, err
	}

	// Marshal and validate payload size
	payload, err := json.Marshal(input.Payload)
	if err != nil {
		return nil, fmt.Errorf("invalid payload: %w", err)
	}
	if err := config.ValidatePayloadSize(payload); err != nil {
		return nil, err
	}

	// Look up event type and validate payload against schema if defined
	eventType, err := r.EventTypeStore.GetByName(ctx, clientID, input.EventType)
	if err == nil && eventType.HasSchema() {
		// Event type exists and has a schema - validate payload
		if err := config.ValidatePayloadAgainstSchema(payload, eventType.Schema); err != nil {
			return nil, fmt.Errorf("payload validation failed for event type %s: %w", input.EventType, err)
		}
	}
	// If event type not found, we allow sending (event types are optional)

	// Validate and compute scheduling
	scheduledAt, err := validateScheduling(input.DeliverAt, input.DelaySeconds)
	if err != nil {
		return nil, err
	}

	// Validate priority
	priority := domain.DefaultPriority
	if input.Priority != nil {
		if *input.Priority < 1 || *input.Priority > 10 {
			return nil, fmt.Errorf("priority must be between 1 and 10")
		}
		priority = *input.Priority
	}

	// Parse headers
	var headers map[string]string
	if input.Headers != nil {
		headers = make(map[string]string)
		for k, v := range input.Headers {
			if s, ok := v.(string); ok {
				headers[k] = s
			}
		}
	}

	// Create events with fanout to all subscribed endpoints
	// Events are created with outbox entries - the outbox processor handles
	// enqueuing with correct priority and scheduling (transactional outbox pattern)
	events, err := r.Store.CreateEventWithFanoutAndOptions(ctx, clientID, input.EventType, idempotencyKey, payload, headers, priority, scheduledAt)
	if err != nil {
		return nil, err
	}

	if len(events) == 0 {
		return nil, fmt.Errorf("no endpoints subscribed to event type: %s", input.EventType)
	}

	result := make([]Event, len(events))
	for i, evt := range events {
		result[i] = *domainEventToGQL(evt)
	}
	return result, nil
}

// ReplayEvent is the resolver for the replayEvent field.
func (r *mutationResolver) ReplayEvent(ctx context.Context, id string) (*Event, error) {
	uid, err := uuid.Parse(id)
	if err != nil {
		return nil, fmt.Errorf("invalid event ID: %w", err)
	}

	evt, err := r.Store.GetByID(ctx, uid)
	if err != nil {
		return nil, err
	}

	if evt.Status != domain.EventStatusDead && evt.Status != domain.EventStatusFailed {
		return nil, fmt.Errorf("can only replay dead or failed events")
	}

	// Use domain method for immutability
	evt = evt.Replay()

	evt, err = r.Store.Update(ctx, evt)
	if err != nil {
		return nil, err
	}

	if err := r.Queue.Enqueue(ctx, evt.ID); err != nil {
		return nil, fmt.Errorf("failed to enqueue event: %w", err)
	}

	return domainEventToGQL(evt), nil
}

// RetryEvents is the resolver for the retryEvents field.
func (r *mutationResolver) RetryEvents(ctx context.Context, ids []string) (*BatchRetryResult, error) {
	uuids := make([]uuid.UUID, 0, len(ids))
	for _, idStr := range ids {
		uid, err := uuid.Parse(idStr)
		if err != nil {
			return nil, fmt.Errorf("invalid event ID %s: %w", idStr, err)
		}
		uuids = append(uuids, uid)
	}

	result, err := r.Store.RetryEventsByIDs(ctx, uuids)
	if err != nil {
		return nil, err
	}

	// Enqueue all successfully retried events
	for _, evt := range result.Succeeded {
		if qErr := r.Queue.Enqueue(ctx, evt.ID); qErr != nil {
			// Log but don't fail - events are already reset for retry
			continue
		}
	}

	return storeBatchResultToGQL(result), nil
}

// RetryEventsByStatus is the resolver for the retryEventsByStatus field.
func (r *mutationResolver) RetryEventsByStatus(ctx context.Context, status EventStatus, limit *int) (*BatchRetryResult, error) {
	domainStatus := gqlStatusToDomain(status)
	if domainStatus != domain.EventStatusFailed && domainStatus != domain.EventStatusDead {
		return nil, fmt.Errorf("only FAILED or DEAD events can be retried")
	}

	l := 100
	if limit != nil && *limit > 0 {
		l = *limit
		if l > 1000 {
			l = 1000
		}
	}

	result, err := r.Store.RetryEventsByStatus(ctx, domainStatus, l)
	if err != nil {
		return nil, err
	}

	// Enqueue all successfully retried events
	for _, evt := range result.Succeeded {
		if qErr := r.Queue.Enqueue(ctx, evt.ID); qErr != nil {
			continue
		}
	}

	return storeBatchResultToGQL(result), nil
}

// RetryEventsByEndpoint is the resolver for the retryEventsByEndpoint field.
func (r *mutationResolver) RetryEventsByEndpoint(ctx context.Context, endpointID string, status *EventStatus, limit *int) (*BatchRetryResult, error) {
	uid, err := uuid.Parse(endpointID)
	if err != nil {
		return nil, fmt.Errorf("invalid endpoint ID: %w", err)
	}

	// Default to failed status
	domainStatus := domain.EventStatusFailed
	if status != nil {
		domainStatus = gqlStatusToDomain(*status)
	}

	if domainStatus != domain.EventStatusFailed && domainStatus != domain.EventStatusDead {
		return nil, fmt.Errorf("only FAILED or DEAD events can be retried")
	}

	l := 100
	if limit != nil && *limit > 0 {
		l = *limit
		if l > 1000 {
			l = 1000
		}
	}

	result, err := r.Store.RetryEventsByEndpoint(ctx, uid, domainStatus, l)
	if err != nil {
		return nil, err
	}

	// Enqueue all successfully retried events
	for _, evt := range result.Succeeded {
		if qErr := r.Queue.Enqueue(ctx, evt.ID); qErr != nil {
			continue
		}
	}

	return storeBatchResultToGQL(result), nil
}

// CreateEndpoint is the resolver for the createEndpoint field.
func (r *mutationResolver) CreateEndpoint(ctx context.Context, input CreateEndpointInput) (*Endpoint, error) {
	clientID, err := auth.RequireClientID(ctx)
	if err != nil {
		return nil, err
	}

	// Validate destination URL (SSRF protection)
	if err := config.ValidateDestinationURL(input.URL); err != nil {
		return nil, fmt.Errorf("invalid URL: %w", err)
	}

	// Build endpoint with defaults
	endpoint := domain.Endpoint{
		ID:               uuid.New(),
		ClientID:         clientID,
		URL:              input.URL,
		EventTypes:       input.EventTypes,
		Status:           domain.EndpointStatusActive,
		MaxRetries:       10,
		RetryBackoffMs:   1000,
		RetryBackoffMax:  86400000,
		RetryBackoffMult: 2.0,
		TimeoutMs:        30000,
		RateLimitPerSec:  0,
		CircuitThreshold: 5,
		CircuitResetMs:   300000,
	}

	// Apply optional fields
	if input.Description != nil {
		endpoint.Description = *input.Description
	}
	if input.MaxRetries != nil {
		endpoint.MaxRetries = *input.MaxRetries
	}
	if input.RetryBackoffMs != nil {
		endpoint.RetryBackoffMs = *input.RetryBackoffMs
	}
	if input.RetryBackoffMax != nil {
		endpoint.RetryBackoffMax = *input.RetryBackoffMax
	}
	if input.RetryBackoffMult != nil {
		endpoint.RetryBackoffMult = *input.RetryBackoffMult
	}
	if input.TimeoutMs != nil {
		endpoint.TimeoutMs = *input.TimeoutMs
	}
	if input.RateLimitPerSec != nil {
		endpoint.RateLimitPerSec = *input.RateLimitPerSec
	}
	if input.CircuitThreshold != nil {
		endpoint.CircuitThreshold = *input.CircuitThreshold
	}
	if input.CircuitResetMs != nil {
		endpoint.CircuitResetMs = *input.CircuitResetMs
	}
	if input.CustomHeaders != nil {
		endpoint.CustomHeaders = make(map[string]string)
		for k, v := range input.CustomHeaders {
			if s, ok := v.(string); ok {
				endpoint.CustomHeaders[k] = s
			}
		}
	}
	if input.Filter != nil {
		filterBytes, err := json.Marshal(input.Filter)
		if err != nil {
			return nil, fmt.Errorf("invalid filter: %w", err)
		}
		// Validate the filter
		if _, err := domain.ParseFilter(filterBytes); err != nil {
			return nil, fmt.Errorf("invalid filter: %w", err)
		}
		endpoint.Filter = filterBytes
	}
	if input.Transformation != nil && *input.Transformation != "" {
		// Validate the transformation code
		if err := r.Transformer.Validate(*input.Transformation); err != nil {
			return nil, fmt.Errorf("invalid transformation: %w", err)
		}
		endpoint.Transformation = *input.Transformation
	}
	if input.Fifo != nil {
		endpoint.FIFO = *input.Fifo
	}
	if input.FifoPartitionKey != nil {
		endpoint.FIFOPartitionKey = *input.FifoPartitionKey
	}

	// Validate FIFO configuration
	if err := validateFIFOConfig(endpoint.FIFO, endpoint.FIFOPartitionKey); err != nil {
		return nil, err
	}

	created, err := r.Store.CreateEndpoint(ctx, endpoint)
	if err != nil {
		return nil, err
	}

	return domainEndpointToGQL(created), nil
}

// UpdateEndpoint is the resolver for the updateEndpoint field.
func (r *mutationResolver) UpdateEndpoint(ctx context.Context, id string, input UpdateEndpointInput) (*Endpoint, error) {
	clientID, err := auth.RequireClientID(ctx)
	if err != nil {
		return nil, err
	}

	uid, err := uuid.Parse(id)
	if err != nil {
		return nil, fmt.Errorf("invalid endpoint ID: %w", err)
	}

	// Get existing endpoint
	endpoint, err := r.Store.GetEndpointByID(ctx, uid)
	if err != nil {
		return nil, err
	}

	// Verify ownership
	if endpoint.ClientID != clientID {
		return nil, domain.ErrEndpointNotFound
	}

	// Apply updates
	if input.URL != nil {
		if err := config.ValidateDestinationURL(*input.URL); err != nil {
			return nil, fmt.Errorf("invalid URL: %w", err)
		}
		endpoint.URL = *input.URL
	}
	if input.Description != nil {
		endpoint.Description = *input.Description
	}
	if input.EventTypes != nil {
		endpoint.EventTypes = input.EventTypes
	}
	if input.Status != nil {
		endpoint.Status = gqlEndpointStatusToDomain(*input.Status)
	}
	if input.MaxRetries != nil {
		endpoint.MaxRetries = *input.MaxRetries
	}
	if input.RetryBackoffMs != nil {
		endpoint.RetryBackoffMs = *input.RetryBackoffMs
	}
	if input.RetryBackoffMax != nil {
		endpoint.RetryBackoffMax = *input.RetryBackoffMax
	}
	if input.RetryBackoffMult != nil {
		endpoint.RetryBackoffMult = *input.RetryBackoffMult
	}
	if input.TimeoutMs != nil {
		endpoint.TimeoutMs = *input.TimeoutMs
	}
	if input.RateLimitPerSec != nil {
		endpoint.RateLimitPerSec = *input.RateLimitPerSec
	}
	if input.CircuitThreshold != nil {
		endpoint.CircuitThreshold = *input.CircuitThreshold
	}
	if input.CircuitResetMs != nil {
		endpoint.CircuitResetMs = *input.CircuitResetMs
	}
	if input.CustomHeaders != nil {
		endpoint.CustomHeaders = make(map[string]string)
		for k, v := range input.CustomHeaders {
			if s, ok := v.(string); ok {
				endpoint.CustomHeaders[k] = s
			}
		}
	}
	if input.Filter != nil {
		filterBytes, err := json.Marshal(input.Filter)
		if err != nil {
			return nil, fmt.Errorf("invalid filter: %w", err)
		}
		// Validate the filter (empty filter is valid - clears the filter)
		if len(filterBytes) > 2 { // More than just "{}"
			if _, err := domain.ParseFilter(filterBytes); err != nil {
				return nil, fmt.Errorf("invalid filter: %w", err)
			}
		}
		endpoint.Filter = filterBytes
	}
	if input.Transformation != nil {
		if *input.Transformation == "" {
			// Clear transformation
			endpoint.Transformation = ""
		} else {
			// Validate the transformation code
			if err := r.Transformer.Validate(*input.Transformation); err != nil {
				return nil, fmt.Errorf("invalid transformation: %w", err)
			}
			endpoint.Transformation = *input.Transformation
		}
	}
	if input.Fifo != nil {
		endpoint.FIFO = *input.Fifo
	}
	if input.FifoPartitionKey != nil {
		endpoint.FIFOPartitionKey = *input.FifoPartitionKey
	}

	// Validate FIFO configuration
	if err := validateFIFOConfig(endpoint.FIFO, endpoint.FIFOPartitionKey); err != nil {
		return nil, err
	}

	updated, err := r.Store.UpdateEndpoint(ctx, endpoint)
	if err != nil {
		return nil, err
	}

	return domainEndpointToGQL(updated), nil
}

// DeleteEndpoint is the resolver for the deleteEndpoint field.
func (r *mutationResolver) DeleteEndpoint(ctx context.Context, id string) (bool, error) {
	clientID, err := auth.RequireClientID(ctx)
	if err != nil {
		return false, err
	}

	uid, err := uuid.Parse(id)
	if err != nil {
		return false, fmt.Errorf("invalid endpoint ID: %w", err)
	}

	// Verify ownership before delete
	endpoint, err := r.Store.GetEndpointByID(ctx, uid)
	if err != nil {
		return false, err
	}
	if endpoint.ClientID != clientID {
		return false, domain.ErrEndpointNotFound
	}

	if err := r.Store.DeleteEndpoint(ctx, uid); err != nil {
		return false, err
	}

	return true, nil
}

// PauseEndpoint is the resolver for the pauseEndpoint field.
func (r *mutationResolver) PauseEndpoint(ctx context.Context, id string) (*Endpoint, error) {
	clientID, err := auth.RequireClientID(ctx)
	if err != nil {
		return nil, err
	}

	uid, err := uuid.Parse(id)
	if err != nil {
		return nil, fmt.Errorf("invalid endpoint ID: %w", err)
	}

	endpoint, err := r.Store.GetEndpointByID(ctx, uid)
	if err != nil {
		return nil, err
	}
	if endpoint.ClientID != clientID {
		return nil, domain.ErrEndpointNotFound
	}

	endpoint.Status = domain.EndpointStatusPaused

	updated, err := r.Store.UpdateEndpoint(ctx, endpoint)
	if err != nil {
		return nil, err
	}

	return domainEndpointToGQL(updated), nil
}

// ResumeEndpoint is the resolver for the resumeEndpoint field.
func (r *mutationResolver) ResumeEndpoint(ctx context.Context, id string) (*Endpoint, error) {
	clientID, err := auth.RequireClientID(ctx)
	if err != nil {
		return nil, err
	}

	uid, err := uuid.Parse(id)
	if err != nil {
		return nil, fmt.Errorf("invalid endpoint ID: %w", err)
	}

	endpoint, err := r.Store.GetEndpointByID(ctx, uid)
	if err != nil {
		return nil, err
	}
	if endpoint.ClientID != clientID {
		return nil, domain.ErrEndpointNotFound
	}

	endpoint.Status = domain.EndpointStatusActive

	updated, err := r.Store.UpdateEndpoint(ctx, endpoint)
	if err != nil {
		return nil, err
	}

	return domainEndpointToGQL(updated), nil
}

// RotateEndpointSecret is the resolver for the rotateEndpointSecret field.
func (r *mutationResolver) RotateEndpointSecret(ctx context.Context, id string) (*EndpointSecretRotation, error) {
	clientID, err := auth.RequireClientID(ctx)
	if err != nil {
		return nil, err
	}

	uid, err := uuid.Parse(id)
	if err != nil {
		return nil, fmt.Errorf("invalid endpoint ID: %w", err)
	}

	// Get existing endpoint
	endpoint, err := r.Store.GetEndpointByID(ctx, uid)
	if err != nil {
		return nil, err
	}

	// Verify ownership
	if endpoint.ClientID != clientID {
		return nil, domain.ErrEndpointNotFound
	}

	// Generate new secret
	newSecret, err := generateSecret(32)
	if err != nil {
		return nil, fmt.Errorf("failed to generate secret: %w", err)
	}

	// Rotate the secret
	endpoint = endpoint.RotateSecret(newSecret)

	updated, err := r.Store.UpdateEndpoint(ctx, endpoint)
	if err != nil {
		return nil, err
	}

	return &EndpointSecretRotation{
		Endpoint:  domainEndpointToGQL(updated),
		NewSecret: newSecret,
	}, nil
}

// ClearPreviousSecret is the resolver for the clearPreviousSecret field.
func (r *mutationResolver) ClearPreviousSecret(ctx context.Context, id string) (*Endpoint, error) {
	clientID, err := auth.RequireClientID(ctx)
	if err != nil {
		return nil, err
	}

	uid, err := uuid.Parse(id)
	if err != nil {
		return nil, fmt.Errorf("invalid endpoint ID: %w", err)
	}

	// Get existing endpoint
	endpoint, err := r.Store.GetEndpointByID(ctx, uid)
	if err != nil {
		return nil, err
	}

	// Verify ownership
	if endpoint.ClientID != clientID {
		return nil, domain.ErrEndpointNotFound
	}

	// Clear previous secret
	endpoint = endpoint.ClearPreviousSecret()

	updated, err := r.Store.UpdateEndpoint(ctx, endpoint)
	if err != nil {
		return nil, err
	}

	return domainEndpointToGQL(updated), nil
}

// CreateEventType is the resolver for the createEventType field.
func (r *mutationResolver) CreateEventType(ctx context.Context, input CreateEventTypeInput) (*EventType, error) {
	clientID, err := auth.RequireClientID(ctx)
	if err != nil {
		return nil, err
	}

	// Validate event type name
	if input.Name == "" {
		return nil, fmt.Errorf("event type name is required")
	}

	// Parse and validate schema if provided
	var schemaBytes []byte
	if input.Schema != nil {
		schemaBytes, err = json.Marshal(input.Schema)
		if err != nil {
			return nil, fmt.Errorf("invalid schema: %w", err)
		}
		if err := config.ValidateJSONSchema(schemaBytes); err != nil {
			return nil, err
		}
	}

	// Create event type
	description := ""
	if input.Description != nil {
		description = *input.Description
	}

	et := domain.NewEventType(clientID, input.Name, description)

	if len(schemaBytes) > 0 {
		version := ""
		if input.SchemaVersion != nil {
			version = *input.SchemaVersion
		}
		et = et.WithSchema(schemaBytes, version)
	}

	created, err := r.EventTypeStore.Create(ctx, et)
	if err != nil {
		return nil, err
	}

	return domainEventTypeToGQL(created), nil
}

// UpdateEventType is the resolver for the updateEventType field.
func (r *mutationResolver) UpdateEventType(ctx context.Context, id string, input UpdateEventTypeInput) (*EventType, error) {
	clientID, err := auth.RequireClientID(ctx)
	if err != nil {
		return nil, err
	}

	uid, err := uuid.Parse(id)
	if err != nil {
		return nil, fmt.Errorf("invalid event type ID: %w", err)
	}

	// Get existing event type
	et, err := r.EventTypeStore.GetByID(ctx, uid)
	if err != nil {
		return nil, err
	}

	// Verify ownership
	if et.ClientID != clientID {
		return nil, domain.ErrEventTypeNotFound
	}

	// Apply updates
	if input.Description != nil {
		et = et.WithDescription(*input.Description)
	}

	if input.Schema != nil {
		schemaBytes, err := json.Marshal(input.Schema)
		if err != nil {
			return nil, fmt.Errorf("invalid schema: %w", err)
		}
		if err := config.ValidateJSONSchema(schemaBytes); err != nil {
			return nil, err
		}
		version := et.SchemaVersion
		if input.SchemaVersion != nil {
			version = *input.SchemaVersion
		}
		et = et.WithSchema(schemaBytes, version)
	} else if input.SchemaVersion != nil {
		// Update version only if schema exists
		et = et.WithSchema(et.Schema, *input.SchemaVersion)
	}

	updated, err := r.EventTypeStore.Update(ctx, et)
	if err != nil {
		return nil, err
	}

	return domainEventTypeToGQL(updated), nil
}

// DeleteEventType is the resolver for the deleteEventType field.
func (r *mutationResolver) DeleteEventType(ctx context.Context, id string) (bool, error) {
	clientID, err := auth.RequireClientID(ctx)
	if err != nil {
		return false, err
	}

	uid, err := uuid.Parse(id)
	if err != nil {
		return false, fmt.Errorf("invalid event type ID: %w", err)
	}

	// Get existing event type to verify ownership
	et, err := r.EventTypeStore.GetByID(ctx, uid)
	if err != nil {
		return false, err
	}

	if et.ClientID != clientID {
		return false, domain.ErrEventTypeNotFound
	}

	if err := r.EventTypeStore.Delete(ctx, uid); err != nil {
		return false, err
	}

	return true, nil
}

// TestTransformation is the resolver for the testTransformation field.
func (r *mutationResolver) TestTransformation(ctx context.Context, input TestTransformationInput) (*TransformationTestResult, error) {
	// Build transformation input from webhook input
	method := "POST"
	if input.Webhook.Method != nil {
		method = *input.Webhook.Method
	}

	headers := make(map[string]string)
	if input.Webhook.Headers != nil {
		for k, v := range input.Webhook.Headers {
			if s, ok := v.(string); ok {
				headers[k] = s
			}
		}
	}

	payloadBytes, err := json.Marshal(input.Webhook.Payload)
	if err != nil {
		return nil, fmt.Errorf("invalid payload: %w", err)
	}

	transformInput := domain.NewTransformationInput(
		method,
		input.Webhook.URL,
		headers,
		payloadBytes,
	)

	// Execute transformation
	start := timeNow()
	result, execErr := r.Transformer.Execute(ctx, input.Code, transformInput)
	executionMs := int(timeNow().Sub(start).Milliseconds())

	response := &TransformationTestResult{
		ExecutionMs: executionMs,
	}

	if execErr != nil {
		if execErr == domain.ErrTransformationCancelled {
			// Cancellation is a valid result
			response.Success = true
			response.Result = &TransformationResult{
				Method:  result.Method,
				URL:     result.URL,
				Headers: mapStringToAny(result.Headers),
				Payload: jsonToMap(result.Payload),
				Cancel:  true,
			}
		} else {
			response.Success = false
			errStr := execErr.Error()
			response.Error = &errStr
		}
	} else {
		response.Success = true
		response.Result = &TransformationResult{
			Method:  result.Method,
			URL:     result.URL,
			Headers: mapStringToAny(result.Headers),
			Payload: jsonToMap(result.Payload),
			Cancel:  result.Cancel,
		}
	}

	return response, nil
}

// ReleaseFIFOLock is the resolver for the releaseFIFOLock field.
func (r *mutationResolver) ReleaseFIFOLock(ctx context.Context, endpointID string, partitionKey *string) (bool, error) {
	pk := ""
	if partitionKey != nil {
		pk = *partitionKey
	}

	if err := r.Queue.ReleaseFIFOLock(ctx, endpointID, pk); err != nil {
		return false, err
	}
	return true, nil
}

// DrainFIFOQueue is the resolver for the drainFIFOQueue field.
func (r *mutationResolver) DrainFIFOQueue(ctx context.Context, endpointID string, partitionKey *string, moveToStandard *bool) (*FIFODrainResult, error) {
	pk := ""
	if partitionKey != nil {
		pk = *partitionKey
	}

	move := false
	if moveToStandard != nil {
		move = *moveToStandard
	}

	var messagesDrained int
	var err error

	if move {
		messagesDrained, err = r.Queue.MoveFIFOToStandardQueue(ctx, endpointID, pk)
	} else {
		messages, drainErr := r.Queue.DrainFIFOQueue(ctx, endpointID, pk)
		err = drainErr
		messagesDrained = len(messages)
	}

	if err != nil {
		return nil, err
	}

	return &FIFODrainResult{
		EndpointID:      endpointID,
		PartitionKey:    partitionKey,
		MessagesDrained: messagesDrained,
		MovedToStandard: move,
	}, nil
}

// RecoverStaleFIFOMessages is the resolver for the recoverStaleFIFOMessages field.
func (r *mutationResolver) RecoverStaleFIFOMessages(ctx context.Context) (*FIFORecoveryResult, error) {
	recovered, err := r.Queue.RecoverAllStaleFIFO(ctx)
	if err != nil {
		return nil, err
	}

	return &FIFORecoveryResult{
		MessagesRecovered: recovered,
	}, nil
}

// CancelScheduledEvent is the resolver for the cancelScheduledEvent field.
func (r *mutationResolver) CancelScheduledEvent(ctx context.Context, id string) (*Event, error) {
	uid, err := uuid.Parse(id)
	if err != nil {
		return nil, fmt.Errorf("invalid event ID: %w", err)
	}

	evt, err := r.Store.GetByID(ctx, uid)
	if err != nil {
		return nil, err
	}

	// Validate that the event can be cancelled
	if evt.Status != domain.EventStatusQueued {
		return nil, fmt.Errorf("can only cancel events in QUEUED status, current status: %s", evt.Status)
	}

	if !evt.IsScheduled() {
		return nil, fmt.Errorf("event is not scheduled for future delivery")
	}

	// Mark the event as dead (cancelled)
	evt = evt.MarkDead()

	// Update in store
	evt, err = r.Store.Update(ctx, evt)
	if err != nil {
		return nil, err
	}

	// Remove from delayed queue if present
	if removeErr := r.Queue.RemoveFromDelayed(ctx, uid); removeErr != nil {
		// Log but don't fail - the event is already marked as cancelled in the database.
		// The delayed queue processor will skip dead events anyway.
		// This could happen if the event was already moved to a priority queue.
		r.Logger.Warn("failed to remove cancelled event from delayed queue",
			"event_id", uid,
			"error", removeErr,
		)
	}

	return domainEventToGQL(evt), nil
}

// CreateAlertRule is the resolver for the createAlertRule field.
func (r *mutationResolver) CreateAlertRule(ctx context.Context, input CreateAlertRuleInput) (*AlertRule, error) {
	if r.AlertEngine == nil {
		return nil, fmt.Errorf("alerting not configured")
	}

	condition := alerting.Condition{
		Metric:   gqlMetricToAlertingMetric(input.Condition.Metric),
		Operator: gqlOperatorToAlertingOperator(input.Condition.Operator),
		Value:    input.Condition.Value,
		Window:   alerting.Duration(parseDurationOrDefault(input.Condition.Window, 5*time.Minute)),
	}

	action := alerting.Action{
		Type:   gqlActionTypeToAlertingActionType(input.Action.Type),
		Config: gqlActionConfigToAlertingConfig(input.Action),
	}
	if input.Action.Message != nil {
		action.Message = *input.Action.Message
	}

	rule := alerting.NewRule(input.Name, condition, action)
	if input.Description != nil {
		rule.Description = *input.Description
	}
	if input.Cooldown != nil {
		rule.Cooldown = alerting.Duration(parseDurationOrDefault(*input.Cooldown, 15*time.Minute))
	}

	if err := r.AlertEngine.AddRule(rule); err != nil {
		return nil, err
	}

	return alertingRuleToGQL(rule), nil
}

// UpdateAlertRule is the resolver for the updateAlertRule field.
func (r *mutationResolver) UpdateAlertRule(ctx context.Context, id string, input UpdateAlertRuleInput) (*AlertRule, error) {
	if r.AlertEngine == nil {
		return nil, fmt.Errorf("alerting not configured")
	}

	uid, err := uuid.Parse(id)
	if err != nil {
		return nil, fmt.Errorf("invalid rule ID: %w", err)
	}

	rule, err := r.AlertEngine.GetRule(uid)
	if err != nil {
		return nil, err
	}

	if input.Name != nil {
		rule.Name = *input.Name
	}
	if input.Description != nil {
		rule.Description = *input.Description
	}
	if input.Enabled != nil {
		rule.Enabled = *input.Enabled
	}
	if input.Condition != nil {
		rule.Condition = alerting.Condition{
			Metric:   gqlMetricToAlertingMetric(input.Condition.Metric),
			Operator: gqlOperatorToAlertingOperator(input.Condition.Operator),
			Value:    input.Condition.Value,
			Window:   alerting.Duration(parseDurationOrDefault(input.Condition.Window, 5*time.Minute)),
		}
	}
	if input.Action != nil {
		rule.Action = alerting.Action{
			Type:   gqlActionTypeToAlertingActionType(input.Action.Type),
			Config: gqlActionConfigToAlertingConfig(input.Action),
		}
		if input.Action.Message != nil {
			rule.Action.Message = *input.Action.Message
		}
	}
	if input.Cooldown != nil {
		rule.Cooldown = alerting.Duration(parseDurationOrDefault(*input.Cooldown, 15*time.Minute))
	}

	if err := r.AlertEngine.UpdateRule(rule); err != nil {
		return nil, err
	}

	return alertingRuleToGQL(rule), nil
}

// DeleteAlertRule is the resolver for the deleteAlertRule field.
func (r *mutationResolver) DeleteAlertRule(ctx context.Context, id string) (bool, error) {
	if r.AlertEngine == nil {
		return false, fmt.Errorf("alerting not configured")
	}

	uid, err := uuid.Parse(id)
	if err != nil {
		return false, fmt.Errorf("invalid rule ID: %w", err)
	}

	if err := r.AlertEngine.RemoveRule(uid); err != nil {
		return false, err
	}

	return true, nil
}

// EnableAlertRule is the resolver for the enableAlertRule field.
func (r *mutationResolver) EnableAlertRule(ctx context.Context, id string) (*AlertRule, error) {
	if r.AlertEngine == nil {
		return nil, fmt.Errorf("alerting not configured")
	}

	uid, err := uuid.Parse(id)
	if err != nil {
		return nil, fmt.Errorf("invalid rule ID: %w", err)
	}

	if err := r.AlertEngine.EnableRule(uid); err != nil {
		return nil, err
	}

	rule, err := r.AlertEngine.GetRule(uid)
	if err != nil {
		return nil, err
	}

	return alertingRuleToGQL(rule), nil
}

// DisableAlertRule is the resolver for the disableAlertRule field.
func (r *mutationResolver) DisableAlertRule(ctx context.Context, id string) (*AlertRule, error) {
	if r.AlertEngine == nil {
		return nil, fmt.Errorf("alerting not configured")
	}

	uid, err := uuid.Parse(id)
	if err != nil {
		return nil, fmt.Errorf("invalid rule ID: %w", err)
	}

	if err := r.AlertEngine.DisableRule(uid); err != nil {
		return nil, err
	}

	rule, err := r.AlertEngine.GetRule(uid)
	if err != nil {
		return nil, err
	}

	return alertingRuleToGQL(rule), nil
}

// EvaluateAlertRules is the resolver for the evaluateAlertRules field.
func (r *mutationResolver) EvaluateAlertRules(ctx context.Context) (bool, error) {
	if r.AlertEngine == nil {
		return false, fmt.Errorf("alerting not configured")
	}

	r.AlertEngine.EvaluateNow(ctx)
	return true, nil
}

// CreateConnector is the resolver for the createConnector field.
func (r *mutationResolver) CreateConnector(ctx context.Context, input CreateConnectorInput) (*Connector, error) {
	if r.ConnectorRegistry == nil {
		return nil, fmt.Errorf("connector registry not configured")
	}

	c := &connector.Connector{
		Type:     gqlConnectorTypeToConnector(input.Type),
		Config:   gqlConnectorConfigToConnector(input.Config),
		Template: gqlConnectorTemplateToConnector(input.Template),
	}

	if err := r.ConnectorRegistry.Register(input.Name, c); err != nil {
		return nil, err
	}

	return connectorToGQL(input.Name, c), nil
}

// UpdateConnector is the resolver for the updateConnector field.
func (r *mutationResolver) UpdateConnector(ctx context.Context, name string, input UpdateConnectorInput) (*Connector, error) {
	if r.ConnectorRegistry == nil {
		return nil, fmt.Errorf("connector registry not configured")
	}

	existing, ok := r.ConnectorRegistry.Get(name)
	if !ok {
		return nil, fmt.Errorf("connector not found: %s", name)
	}

	// Update config if provided
	if input.Config != nil {
		existing.Config = gqlConnectorConfigToConnector(input.Config)
	}

	// Update template if provided
	if input.Template != nil {
		existing.Template = gqlConnectorTemplateToConnector(input.Template)
	}

	// Re-register to validate
	r.ConnectorRegistry.Delete(name)
	if err := r.ConnectorRegistry.Register(name, existing); err != nil {
		return nil, err
	}

	return connectorToGQL(name, existing), nil
}

// DeleteConnector is the resolver for the deleteConnector field.
func (r *mutationResolver) DeleteConnector(ctx context.Context, name string) (bool, error) {
	if r.ConnectorRegistry == nil {
		return false, fmt.Errorf("connector registry not configured")
	}

	_, ok := r.ConnectorRegistry.Get(name)
	if !ok {
		return false, fmt.Errorf("connector not found: %s", name)
	}

	r.ConnectorRegistry.Delete(name)
	return true, nil
}

// Event is the resolver for the event field.
func (r *queryResolver) Event(ctx context.Context, id string) (*Event, error) {
	uid, err := uuid.Parse(id)
	if err != nil {
		return nil, fmt.Errorf("invalid event ID: %w", err)
	}

	evt, err := r.Store.GetByID(ctx, uid)
	if err != nil {
		return nil, err
	}

	return domainEventToGQL(evt), nil
}

// Events is the resolver for the events field.
func (r *queryResolver) Events(ctx context.Context, status *EventStatus, first *int, after *string) (*EventConnection, error) {
	limit := 20
	if first != nil && *first > 0 {
		limit = *first
		if limit > 100 {
			limit = 100
		}
	}

	offset := 0
	if after != nil {
		decoded, err := base64.StdEncoding.DecodeString(*after)
		if err == nil {
			offset, _ = strconv.Atoi(string(decoded))
		}
	}

	var events []domain.Event
	var err error

	if status != nil {
		events, err = r.Store.ListByStatus(ctx, gqlStatusToDomain(*status), limit+1, offset)
	} else {
		events, err = r.Store.ListReadyForDelivery(ctx, limit+1)
	}
	if err != nil {
		return nil, err
	}

	hasNextPage := len(events) > limit
	if hasNextPage {
		events = events[:limit]
	}

	edges := make([]EventEdge, len(events))
	for i, evt := range events {
		cursor := base64.StdEncoding.EncodeToString([]byte(strconv.Itoa(offset + i + 1)))
		edges[i] = EventEdge{
			Node:   domainEventToGQL(evt),
			Cursor: cursor,
		}
	}

	var startCursor, endCursor *string
	if len(edges) > 0 {
		startCursor = &edges[0].Cursor
		endCursor = &edges[len(edges)-1].Cursor
	}

	return &EventConnection{
		Edges: edges,
		PageInfo: &PageInfo{
			HasNextPage:     hasNextPage,
			HasPreviousPage: offset > 0,
			StartCursor:     startCursor,
			EndCursor:       endCursor,
		},
		TotalCount: len(events),
	}, nil
}

// QueueStats is the resolver for the queueStats field.
func (r *queryResolver) QueueStats(ctx context.Context) (*QueueStats, error) {
	dbStats, err := r.Store.GetQueueStats(ctx)
	if err != nil {
		return nil, err
	}

	queueStats, err := r.Queue.Stats(ctx)
	if err != nil {
		return nil, err
	}

	return &QueueStats{
		Queued:     int(dbStats.Queued),
		Delivering: int(dbStats.Delivering),
		Delivered:  int(dbStats.Delivered),
		Failed:     int(dbStats.Failed),
		Dead:       int(dbStats.Dead),
		Pending:    int(queueStats.Pending),
		Processing: int(queueStats.Processing),
		Delayed:    int(queueStats.Delayed),
	}, nil
}

// Endpoint is the resolver for the endpoint field.
func (r *queryResolver) Endpoint(ctx context.Context, id string) (*Endpoint, error) {
	clientID, err := auth.RequireClientID(ctx)
	if err != nil {
		return nil, err
	}

	uid, err := uuid.Parse(id)
	if err != nil {
		return nil, fmt.Errorf("invalid endpoint ID: %w", err)
	}

	endpoint, err := r.Store.GetEndpointByID(ctx, uid)
	if err != nil {
		return nil, err
	}

	// Verify ownership
	if endpoint.ClientID != clientID {
		return nil, domain.ErrEndpointNotFound
	}

	return domainEndpointToGQL(endpoint), nil
}

// Endpoints is the resolver for the endpoints field.
func (r *queryResolver) Endpoints(ctx context.Context, status *EndpointStatus, first *int, after *string) (*EndpointConnection, error) {
	clientID, err := auth.RequireClientID(ctx)
	if err != nil {
		return nil, err
	}

	limit := 20
	if first != nil && *first > 0 {
		limit = *first
		if limit > 100 {
			limit = 100
		}
	}

	offset := 0
	if after != nil {
		decoded, err := base64.StdEncoding.DecodeString(*after)
		if err == nil {
			offset, _ = strconv.Atoi(string(decoded))
		}
	}

	// Fetch one extra to check for next page
	endpoints, err := r.Store.ListEndpointsByClient(ctx, clientID, limit+1, offset)
	if err != nil {
		return nil, err
	}

	// Filter by status if provided (in-memory since DB doesn't filter by status yet)
	var filtered []domain.Endpoint
	for _, ep := range endpoints {
		if status == nil || domainEndpointStatusToGQL(ep.Status) == *status {
			filtered = append(filtered, ep)
		}
	}

	hasNextPage := len(filtered) > limit
	if hasNextPage {
		filtered = filtered[:limit]
	}

	edges := make([]EndpointEdge, len(filtered))
	for i, ep := range filtered {
		cursor := base64.StdEncoding.EncodeToString([]byte(strconv.Itoa(offset + i + 1)))
		edges[i] = EndpointEdge{
			Node:   domainEndpointToGQL(ep),
			Cursor: cursor,
		}
	}

	var startCursor, endCursor *string
	if len(edges) > 0 {
		startCursor = &edges[0].Cursor
		endCursor = &edges[len(edges)-1].Cursor
	}

	return &EndpointConnection{
		Edges: edges,
		PageInfo: &PageInfo{
			HasNextPage:     hasNextPage,
			HasPreviousPage: offset > 0,
			StartCursor:     startCursor,
			EndCursor:       endCursor,
		},
		TotalCount: len(filtered),
	}, nil
}

// EventType is the resolver for the eventType field.
func (r *queryResolver) EventType(ctx context.Context, id string) (*EventType, error) {
	clientID, err := auth.RequireClientID(ctx)
	if err != nil {
		return nil, err
	}

	uid, err := uuid.Parse(id)
	if err != nil {
		return nil, fmt.Errorf("invalid event type ID: %w", err)
	}

	et, err := r.EventTypeStore.GetByID(ctx, uid)
	if err != nil {
		return nil, err
	}

	// Verify ownership
	if et.ClientID != clientID {
		return nil, domain.ErrEventTypeNotFound
	}

	return domainEventTypeToGQL(et), nil
}

// EventTypeByName is the resolver for the eventTypeByName field.
func (r *queryResolver) EventTypeByName(ctx context.Context, name string) (*EventType, error) {
	clientID, err := auth.RequireClientID(ctx)
	if err != nil {
		return nil, err
	}

	et, err := r.EventTypeStore.GetByName(ctx, clientID, name)
	if err != nil {
		return nil, err
	}

	return domainEventTypeToGQL(et), nil
}

// EventTypes is the resolver for the eventTypes field.
func (r *queryResolver) EventTypes(ctx context.Context, first *int, after *string) (*EventTypeConnection, error) {
	clientID, err := auth.RequireClientID(ctx)
	if err != nil {
		return nil, err
	}

	limit := 20
	if first != nil && *first > 0 {
		limit = *first
		if limit > 100 {
			limit = 100
		}
	}

	offset := 0
	if after != nil {
		decoded, err := base64.StdEncoding.DecodeString(*after)
		if err == nil {
			offset, _ = strconv.Atoi(string(decoded))
		}
	}

	// Fetch one extra to check for next page
	eventTypes, err := r.EventTypeStore.List(ctx, clientID, limit+1, offset)
	if err != nil {
		return nil, err
	}

	hasNextPage := len(eventTypes) > limit
	if hasNextPage {
		eventTypes = eventTypes[:limit]
	}

	edges := make([]EventTypeEdge, len(eventTypes))
	for i, et := range eventTypes {
		cursor := base64.StdEncoding.EncodeToString([]byte(strconv.Itoa(offset + i + 1)))
		edges[i] = EventTypeEdge{
			Node:   domainEventTypeToGQL(et),
			Cursor: cursor,
		}
	}

	var startCursor, endCursor *string
	if len(edges) > 0 {
		startCursor = &edges[0].Cursor
		endCursor = &edges[len(edges)-1].Cursor
	}

	return &EventTypeConnection{
		Edges: edges,
		PageInfo: &PageInfo{
			HasNextPage:     hasNextPage,
			HasPreviousPage: offset > 0,
			StartCursor:     startCursor,
			EndCursor:       endCursor,
		},
		TotalCount: len(eventTypes),
	}, nil
}

// FifoQueueStats is the resolver for the fifoQueueStats field.
func (r *queryResolver) FifoQueueStats(ctx context.Context, endpointID string) (*FIFOEndpointStats, error) {
	partitions, err := r.Queue.ListFIFOPartitions(ctx, endpointID)
	if err != nil {
		return nil, err
	}

	var totalQueued int64
	var partitionStats []FIFOQueueStats

	for _, pk := range partitions {
		stats, err := r.Queue.GetFIFOQueueStats(ctx, endpointID, pk)
		if err != nil {
			continue
		}

		totalQueued += stats.QueueLength
		partitionStats = append(partitionStats, FIFOQueueStats{
			EndpointID:   endpointID,
			PartitionKey: pk,
			QueueLength:  int(stats.QueueLength),
			IsLocked:     stats.IsLocked,
			HasInFlight:  stats.HasInFlight,
		})
	}

	return &FIFOEndpointStats{
		EndpointID:          endpointID,
		TotalPartitions:     len(partitions),
		TotalQueuedMessages: int(totalQueued),
		Partitions:          partitionStats,
	}, nil
}

// FifoPartitionStats is the resolver for the fifoPartitionStats field.
func (r *queryResolver) FifoPartitionStats(ctx context.Context, endpointID string, partitionKey string) (*FIFOQueueStats, error) {
	stats, err := r.Queue.GetFIFOQueueStats(ctx, endpointID, partitionKey)
	if err != nil {
		return nil, err
	}

	return &FIFOQueueStats{
		EndpointID:   endpointID,
		PartitionKey: partitionKey,
		QueueLength:  int(stats.QueueLength),
		IsLocked:     stats.IsLocked,
		HasInFlight:  stats.HasInFlight,
	}, nil
}

// ActiveFIFOQueues is the resolver for the activeFIFOQueues field.
func (r *queryResolver) ActiveFIFOQueues(ctx context.Context) ([]FIFOQueueStats, error) {
	queues, err := r.Queue.GetActiveFIFOQueues(ctx)
	if err != nil {
		return nil, err
	}

	var result []FIFOQueueStats
	for _, queueKey := range queues {
		endpointID, partitionKey, ok := queue.ParseFIFOQueueKey(queueKey)
		if !ok {
			continue
		}

		stats, err := r.Queue.GetFIFOQueueStats(ctx, endpointID, partitionKey)
		if err != nil {
			continue
		}

		result = append(result, FIFOQueueStats{
			EndpointID:   endpointID,
			PartitionKey: partitionKey,
			QueueLength:  int(stats.QueueLength),
			IsLocked:     stats.IsLocked,
			HasInFlight:  stats.HasInFlight,
		})
	}

	return result, nil
}

// PriorityQueueStats is the resolver for the priorityQueueStats field.
func (r *queryResolver) PriorityQueueStats(ctx context.Context) (*PriorityQueueStats, error) {
	stats, err := r.Queue.GetPriorityStats(ctx)
	if err != nil {
		return nil, err
	}

	return &PriorityQueueStats{
		High:    int(stats.High),
		Normal:  int(stats.Normal),
		Low:     int(stats.Low),
		Delayed: int(stats.Delayed),
	}, nil
}

// AnalyticsStats is the resolver for the analyticsStats field.
func (r *queryResolver) AnalyticsStats(ctx context.Context, timeRange AnalyticsTimeRange) (*AnalyticsStats, error) {
	if r.MetricsStore == nil {
		return nil, fmt.Errorf("metrics store not configured")
	}

	stats, err := r.MetricsStore.GetStats(ctx, timeRange.Start, timeRange.End)
	if err != nil {
		return nil, err
	}

	return &AnalyticsStats{
		Period:       stats.Period,
		TotalCount:   int(stats.TotalCount),
		SuccessCount: int(stats.SuccessCount),
		FailureCount: int(stats.FailureCount),
		TimeoutCount: int(stats.TimeoutCount),
		SuccessRate:  stats.SuccessRate,
		FailureRate:  stats.FailureRate,
		AvgLatencyMs: stats.AvgLatencyMs,
		P50LatencyMs: stats.P50LatencyMs,
		P95LatencyMs: stats.P95LatencyMs,
		P99LatencyMs: stats.P99LatencyMs,
		MinLatencyMs: int(stats.MinLatencyMs),
		MaxLatencyMs: int(stats.MaxLatencyMs),
	}, nil
}

// SuccessRateTimeSeries is the resolver for the successRateTimeSeries field.
func (r *queryResolver) SuccessRateTimeSeries(ctx context.Context, timeRange AnalyticsTimeRange, granularity TimeGranularity) ([]TimeSeriesPoint, error) {
	if r.MetricsStore == nil {
		return nil, fmt.Errorf("metrics store not configured")
	}

	duration := granularityToDuration(granularity)
	points, err := r.MetricsStore.GetSuccessRateTimeSeries(ctx, timeRange.Start, timeRange.End, duration)
	if err != nil {
		return nil, err
	}

	result := make([]TimeSeriesPoint, len(points))
	for i, p := range points {
		result[i] = TimeSeriesPoint{
			Timestamp: p.Timestamp,
			Value:     p.Value,
		}
	}
	return result, nil
}

// LatencyTimeSeries is the resolver for the latencyTimeSeries field.
func (r *queryResolver) LatencyTimeSeries(ctx context.Context, timeRange AnalyticsTimeRange, granularity TimeGranularity) ([]TimeSeriesPoint, error) {
	if r.MetricsStore == nil {
		return nil, fmt.Errorf("metrics store not configured")
	}

	duration := granularityToDuration(granularity)
	points, err := r.MetricsStore.GetLatencyTimeSeries(ctx, timeRange.Start, timeRange.End, duration)
	if err != nil {
		return nil, err
	}

	result := make([]TimeSeriesPoint, len(points))
	for i, p := range points {
		result[i] = TimeSeriesPoint{
			Timestamp: p.Timestamp,
			Value:     p.Value,
		}
	}
	return result, nil
}

// DeliveryCountTimeSeries is the resolver for the deliveryCountTimeSeries field.
func (r *queryResolver) DeliveryCountTimeSeries(ctx context.Context, timeRange AnalyticsTimeRange, granularity TimeGranularity) ([]TimeSeriesPoint, error) {
	if r.MetricsStore == nil {
		return nil, fmt.Errorf("metrics store not configured")
	}

	duration := granularityToDuration(granularity)
	var points []TimeSeriesPoint

	for t := timeRange.Start; t.Before(timeRange.End); t = t.Add(duration) {
		periodEnd := t.Add(duration)
		if periodEnd.After(timeRange.End) {
			periodEnd = timeRange.End
		}

		count, err := r.MetricsStore.GetDeliveryCount(ctx, periodEnd.Sub(t))
		if err != nil {
			return nil, err
		}

		points = append(points, TimeSeriesPoint{
			Timestamp: t,
			Value:     float64(count),
		})
	}

	return points, nil
}

// BreakdownByEventType is the resolver for the breakdownByEventType field.
func (r *queryResolver) BreakdownByEventType(ctx context.Context, timeRange AnalyticsTimeRange, limit *int) ([]BreakdownItem, error) {
	if r.MetricsStore == nil {
		return nil, fmt.Errorf("metrics store not configured")
	}

	l := 10 // default limit
	if limit != nil {
		l = *limit
	}

	items, err := r.MetricsStore.GetBreakdownByEventType(ctx, timeRange.Start, timeRange.End, l)
	if err != nil {
		return nil, err
	}

	result := make([]BreakdownItem, len(items))
	for i, item := range items {
		result[i] = BreakdownItem{
			Key:          item.Key,
			Count:        int(item.Count),
			SuccessRate:  item.SuccessRate,
			AvgLatencyMs: item.AvgLatency,
		}
	}
	return result, nil
}

// BreakdownByEndpoint is the resolver for the breakdownByEndpoint field.
func (r *queryResolver) BreakdownByEndpoint(ctx context.Context, timeRange AnalyticsTimeRange, limit *int) ([]BreakdownItem, error) {
	if r.MetricsStore == nil {
		return nil, fmt.Errorf("metrics store not configured")
	}

	l := 10 // default limit
	if limit != nil {
		l = *limit
	}

	items, err := r.MetricsStore.GetBreakdownByEndpoint(ctx, timeRange.Start, timeRange.End, l)
	if err != nil {
		return nil, err
	}

	result := make([]BreakdownItem, len(items))
	for i, item := range items {
		result[i] = BreakdownItem{
			Key:          item.Key,
			Count:        int(item.Count),
			SuccessRate:  item.SuccessRate,
			AvgLatencyMs: item.AvgLatency,
		}
	}
	return result, nil
}

// BreakdownByStatus is the resolver for the breakdownByStatus field.
func (r *queryResolver) BreakdownByStatus(ctx context.Context, timeRange AnalyticsTimeRange) ([]BreakdownItem, error) {
	if r.MetricsStore == nil {
		return nil, fmt.Errorf("metrics store not configured")
	}

	items, err := r.MetricsStore.GetBreakdownByStatus(ctx, timeRange.Start, timeRange.End)
	if err != nil {
		return nil, err
	}

	result := make([]BreakdownItem, len(items))
	for i, item := range items {
		result[i] = BreakdownItem{
			Key:          item.Key,
			Count:        int(item.Count),
			SuccessRate:  item.SuccessRate,
			AvgLatencyMs: item.AvgLatency,
		}
	}
	return result, nil
}

// LatencyPercentiles is the resolver for the latencyPercentiles field.
func (r *queryResolver) LatencyPercentiles(ctx context.Context, timeRange AnalyticsTimeRange) (*LatencyPercentiles, error) {
	if r.MetricsStore == nil {
		return nil, fmt.Errorf("metrics store not configured")
	}

	window := timeRange.End.Sub(timeRange.Start)
	p50, p95, p99, err := r.MetricsStore.GetLatencyPercentiles(ctx, window)
	if err != nil {
		return nil, err
	}

	return &LatencyPercentiles{
		P50: p50,
		P95: p95,
		P99: p99,
	}, nil
}

// EndpointAnalytics is the resolver for the endpointAnalytics field.
func (r *queryResolver) EndpointAnalytics(ctx context.Context, endpointID string, timeRange AnalyticsTimeRange) (*AnalyticsStats, error) {
	if r.MetricsStore == nil {
		return nil, fmt.Errorf("metrics store not configured")
	}

	records, err := r.MetricsStore.GetDeliveryRecordsByEndpoint(ctx, endpointID, timeRange.Start, timeRange.End, 0)
	if err != nil {
		return nil, err
	}

	return computeStatsFromRecords(records, timeRange.Start), nil
}

// EventTypeAnalytics is the resolver for the eventTypeAnalytics field.
func (r *queryResolver) EventTypeAnalytics(ctx context.Context, eventType string, timeRange AnalyticsTimeRange) (*AnalyticsStats, error) {
	if r.MetricsStore == nil {
		return nil, fmt.Errorf("metrics store not configured")
	}

	records, err := r.MetricsStore.GetDeliveryRecordsByEventType(ctx, eventType, timeRange.Start, timeRange.End, 0)
	if err != nil {
		return nil, err
	}

	return computeStatsFromRecords(records, timeRange.Start), nil
}

// AlertRule is the resolver for the alertRule field.
func (r *queryResolver) AlertRule(ctx context.Context, id string) (*AlertRule, error) {
	if r.AlertEngine == nil {
		return nil, fmt.Errorf("alerting not configured")
	}

	uid, err := uuid.Parse(id)
	if err != nil {
		return nil, fmt.Errorf("invalid rule ID: %w", err)
	}

	rule, err := r.AlertEngine.GetRule(uid)
	if err != nil {
		return nil, err
	}

	return alertingRuleToGQL(rule), nil
}

// AlertRules is the resolver for the alertRules field.
func (r *queryResolver) AlertRules(ctx context.Context) ([]AlertRule, error) {
	if r.AlertEngine == nil {
		return nil, fmt.Errorf("alerting not configured")
	}

	rules := r.AlertEngine.ListRules()
	result := make([]AlertRule, 0, len(rules))
	for _, rule := range rules {
		result = append(result, *alertingRuleToGQL(rule))
	}

	return result, nil
}

// AlertHistory is the resolver for the alertHistory field.
func (r *queryResolver) AlertHistory(ctx context.Context, limit *int) ([]Alert, error) {
	if r.AlertEngine == nil {
		return nil, fmt.Errorf("alerting not configured")
	}

	historyLimit := 100
	if limit != nil && *limit > 0 {
		historyLimit = *limit
	}

	alerts := r.AlertEngine.GetAlertHistory(historyLimit)
	result := make([]Alert, 0, len(alerts))
	for _, alert := range alerts {
		result = append(result, alertingAlertToGQL(alert))
	}

	return result, nil
}

// Connector is the resolver for the connector field.
func (r *queryResolver) Connector(ctx context.Context, name string) (*Connector, error) {
	if r.ConnectorRegistry == nil {
		return nil, fmt.Errorf("connector registry not configured")
	}

	c, ok := r.ConnectorRegistry.Get(name)
	if !ok {
		return nil, nil
	}

	return connectorToGQL(name, c), nil
}

// Connectors is the resolver for the connectors field.
func (r *queryResolver) Connectors(ctx context.Context) ([]Connector, error) {
	if r.ConnectorRegistry == nil {
		return nil, fmt.Errorf("connector registry not configured")
	}

	names := r.ConnectorRegistry.List()
	result := make([]Connector, 0, len(names))
	for _, name := range names {
		c, ok := r.ConnectorRegistry.Get(name)
		if ok {
			result = append(result, *connectorToGQL(name, c))
		}
	}

	return result, nil
}

// Endpoint returns EndpointResolver implementation.
func (r *Resolver) Endpoint() EndpointResolver { return &endpointResolver{r} }

// Event returns EventResolver implementation.
func (r *Resolver) Event() EventResolver { return &eventResolver{r} }

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type endpointResolver struct{ *Resolver }
type eventResolver struct{ *Resolver }
type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
