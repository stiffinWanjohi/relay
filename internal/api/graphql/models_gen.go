// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package graphql

import (
	"bytes"
	"fmt"
	"io"
	"strconv"
	"time"
)

type Alert struct {
	ID        string    `json:"id"`
	RuleID    string    `json:"ruleId"`
	RuleName  string    `json:"ruleName"`
	Metric    string    `json:"metric"`
	Value     float64   `json:"value"`
	Threshold float64   `json:"threshold"`
	Message   string    `json:"message"`
	FiredAt   time.Time `json:"firedAt"`
}

type AlertAction struct {
	Type       AlertActionType `json:"type"`
	WebhookURL *string         `json:"webhookUrl,omitempty"`
	Channel    *string         `json:"channel,omitempty"`
	To         []string        `json:"to,omitempty"`
	Subject    *string         `json:"subject,omitempty"`
	RoutingKey *string         `json:"routingKey,omitempty"`
	Severity   *string         `json:"severity,omitempty"`
	Message    *string         `json:"message,omitempty"`
}

type AlertActionInput struct {
	Type       AlertActionType `json:"type"`
	WebhookURL *string         `json:"webhookUrl,omitempty"`
	Channel    *string         `json:"channel,omitempty"`
	To         []string        `json:"to,omitempty"`
	Subject    *string         `json:"subject,omitempty"`
	RoutingKey *string         `json:"routingKey,omitempty"`
	Severity   *string         `json:"severity,omitempty"`
	Message    *string         `json:"message,omitempty"`
}

type AlertCondition struct {
	Metric   AlertMetric   `json:"metric"`
	Operator AlertOperator `json:"operator"`
	Value    float64       `json:"value"`
	Window   string        `json:"window"`
}

type AlertConditionInput struct {
	Metric   AlertMetric   `json:"metric"`
	Operator AlertOperator `json:"operator"`
	Value    float64       `json:"value"`
	Window   string        `json:"window"`
}

type AlertRule struct {
	ID          string          `json:"id"`
	Name        string          `json:"name"`
	Description *string         `json:"description,omitempty"`
	Enabled     bool            `json:"enabled"`
	Condition   *AlertCondition `json:"condition"`
	Action      *AlertAction    `json:"action"`
	Cooldown    string          `json:"cooldown"`
	LastFiredAt *time.Time      `json:"lastFiredAt,omitempty"`
	CreatedAt   time.Time       `json:"createdAt"`
	UpdatedAt   time.Time       `json:"updatedAt"`
}

type AnalyticsStats struct {
	Period       string  `json:"period"`
	TotalCount   int     `json:"totalCount"`
	SuccessCount int     `json:"successCount"`
	FailureCount int     `json:"failureCount"`
	TimeoutCount int     `json:"timeoutCount"`
	SuccessRate  float64 `json:"successRate"`
	FailureRate  float64 `json:"failureRate"`
	AvgLatencyMs float64 `json:"avgLatencyMs"`
	P50LatencyMs float64 `json:"p50LatencyMs"`
	P95LatencyMs float64 `json:"p95LatencyMs"`
	P99LatencyMs float64 `json:"p99LatencyMs"`
	MinLatencyMs int     `json:"minLatencyMs"`
	MaxLatencyMs int     `json:"maxLatencyMs"`
}

type AnalyticsTimeRange struct {
	Start time.Time `json:"start"`
	End   time.Time `json:"end"`
}

type BatchRetryError struct {
	EventID string `json:"eventId"`
	Error   string `json:"error"`
}

type BatchRetryResult struct {
	Succeeded      []Event           `json:"succeeded"`
	Failed         []BatchRetryError `json:"failed"`
	TotalRequested int               `json:"totalRequested"`
	TotalSucceeded int               `json:"totalSucceeded"`
}

type BreakdownItem struct {
	Key          string  `json:"key"`
	Count        int     `json:"count"`
	SuccessRate  float64 `json:"successRate"`
	AvgLatencyMs float64 `json:"avgLatencyMs"`
}

type Connector struct {
	Name     string             `json:"name"`
	Type     ConnectorType      `json:"type"`
	Config   *ConnectorConfig   `json:"config"`
	Template *ConnectorTemplate `json:"template"`
}

type ConnectorConfig struct {
	WebhookURL *string  `json:"webhookUrl,omitempty"`
	Channel    *string  `json:"channel,omitempty"`
	Username   *string  `json:"username,omitempty"`
	IconEmoji  *string  `json:"iconEmoji,omitempty"`
	IconURL    *string  `json:"iconUrl,omitempty"`
	SMTPHost   *string  `json:"smtpHost,omitempty"`
	SMTPPort   *int     `json:"smtpPort,omitempty"`
	FromEmail  *string  `json:"fromEmail,omitempty"`
	ToEmails   []string `json:"toEmails,omitempty"`
}

type ConnectorConfigInput struct {
	WebhookURL   *string  `json:"webhookUrl,omitempty"`
	Channel      *string  `json:"channel,omitempty"`
	Username     *string  `json:"username,omitempty"`
	IconEmoji    *string  `json:"iconEmoji,omitempty"`
	IconURL      *string  `json:"iconUrl,omitempty"`
	SMTPHost     *string  `json:"smtpHost,omitempty"`
	SMTPPort     *int     `json:"smtpPort,omitempty"`
	SMTPUsername *string  `json:"smtpUsername,omitempty"`
	SMTPPassword *string  `json:"smtpPassword,omitempty"`
	FromEmail    *string  `json:"fromEmail,omitempty"`
	ToEmails     []string `json:"toEmails,omitempty"`
}

type ConnectorTemplate struct {
	Text    *string `json:"text,omitempty"`
	Title   *string `json:"title,omitempty"`
	Body    *string `json:"body,omitempty"`
	Color   *string `json:"color,omitempty"`
	Subject *string `json:"subject,omitempty"`
}

type ConnectorTemplateInput struct {
	Text    *string `json:"text,omitempty"`
	Title   *string `json:"title,omitempty"`
	Body    *string `json:"body,omitempty"`
	Color   *string `json:"color,omitempty"`
	Subject *string `json:"subject,omitempty"`
}

type CreateAlertRuleInput struct {
	Name        string               `json:"name"`
	Description *string              `json:"description,omitempty"`
	Condition   *AlertConditionInput `json:"condition"`
	Action      *AlertActionInput    `json:"action"`
	Cooldown    *string              `json:"cooldown,omitempty"`
}

type CreateConnectorInput struct {
	Name     string                  `json:"name"`
	Type     ConnectorType           `json:"type"`
	Config   *ConnectorConfigInput   `json:"config"`
	Template *ConnectorTemplateInput `json:"template,omitempty"`
}

type CreateEndpointInput struct {
	URL              string         `json:"url"`
	Description      *string        `json:"description,omitempty"`
	EventTypes       []string       `json:"eventTypes"`
	Filter           map[string]any `json:"filter,omitempty"`
	Transformation   *string        `json:"transformation,omitempty"`
	Fifo             *bool          `json:"fifo,omitempty"`
	FifoPartitionKey *string        `json:"fifoPartitionKey,omitempty"`
	MaxRetries       *int           `json:"maxRetries,omitempty"`
	RetryBackoffMs   *int           `json:"retryBackoffMs,omitempty"`
	RetryBackoffMax  *int           `json:"retryBackoffMax,omitempty"`
	RetryBackoffMult *float64       `json:"retryBackoffMult,omitempty"`
	TimeoutMs        *int           `json:"timeoutMs,omitempty"`
	RateLimitPerSec  *int           `json:"rateLimitPerSec,omitempty"`
	CircuitThreshold *int           `json:"circuitThreshold,omitempty"`
	CircuitResetMs   *int           `json:"circuitResetMs,omitempty"`
	CustomHeaders    map[string]any `json:"customHeaders,omitempty"`
}

type CreateEventInput struct {
	Destination  string         `json:"destination"`
	Payload      map[string]any `json:"payload"`
	Headers      map[string]any `json:"headers,omitempty"`
	MaxAttempts  *int           `json:"maxAttempts,omitempty"`
	Priority     *int           `json:"priority,omitempty"`
	DeliverAt    *time.Time     `json:"deliverAt,omitempty"`
	DelaySeconds *int           `json:"delaySeconds,omitempty"`
}

type CreateEventTypeInput struct {
	Name          string         `json:"name"`
	Description   *string        `json:"description,omitempty"`
	Schema        map[string]any `json:"schema,omitempty"`
	SchemaVersion *string        `json:"schemaVersion,omitempty"`
}

type DeliveryAttempt struct {
	ID            string    `json:"id"`
	EventID       string    `json:"eventId"`
	StatusCode    *int      `json:"statusCode,omitempty"`
	ResponseBody  *string   `json:"responseBody,omitempty"`
	Error         *string   `json:"error,omitempty"`
	DurationMs    int       `json:"durationMs"`
	AttemptNumber int       `json:"attemptNumber"`
	AttemptedAt   time.Time `json:"attemptedAt"`
}

type Endpoint struct {
	ID               string         `json:"id"`
	ClientID         string         `json:"clientId"`
	URL              string         `json:"url"`
	Description      *string        `json:"description,omitempty"`
	EventTypes       []string       `json:"eventTypes"`
	Status           EndpointStatus `json:"status"`
	Filter           map[string]any `json:"filter,omitempty"`
	Transformation   *string        `json:"transformation,omitempty"`
	Fifo             bool           `json:"fifo"`
	FifoPartitionKey *string        `json:"fifoPartitionKey,omitempty"`
	MaxRetries       int            `json:"maxRetries"`
	RetryBackoffMs   int            `json:"retryBackoffMs"`
	RetryBackoffMax  int            `json:"retryBackoffMax"`
	RetryBackoffMult float64        `json:"retryBackoffMult"`
	TimeoutMs        int            `json:"timeoutMs"`
	RateLimitPerSec  int            `json:"rateLimitPerSec"`
	CircuitThreshold int            `json:"circuitThreshold"`
	CircuitResetMs   int            `json:"circuitResetMs"`
	CustomHeaders    map[string]any `json:"customHeaders,omitempty"`
	HasCustomSecret  bool           `json:"hasCustomSecret"`
	SecretRotatedAt  *time.Time     `json:"secretRotatedAt,omitempty"`
	CreatedAt        time.Time      `json:"createdAt"`
	UpdatedAt        time.Time      `json:"updatedAt"`
	Stats            *EndpointStats `json:"stats"`
	RecentEvents     []Event        `json:"recentEvents"`
}

type EndpointConnection struct {
	Edges      []EndpointEdge `json:"edges"`
	PageInfo   *PageInfo      `json:"pageInfo"`
	TotalCount int            `json:"totalCount"`
}

type EndpointEdge struct {
	Node   *Endpoint `json:"node"`
	Cursor string    `json:"cursor"`
}

type EndpointSecretRotation struct {
	Endpoint  *Endpoint `json:"endpoint"`
	NewSecret string    `json:"newSecret"`
}

type EndpointStats struct {
	TotalEvents  int     `json:"totalEvents"`
	Delivered    int     `json:"delivered"`
	Failed       int     `json:"failed"`
	Pending      int     `json:"pending"`
	SuccessRate  float64 `json:"successRate"`
	AvgLatencyMs float64 `json:"avgLatencyMs"`
}

type Event struct {
	ID               string            `json:"id"`
	IdempotencyKey   string            `json:"idempotencyKey"`
	ClientID         *string           `json:"clientId,omitempty"`
	EventType        *string           `json:"eventType,omitempty"`
	EndpointID       *string           `json:"endpointId,omitempty"`
	Destination      string            `json:"destination"`
	Payload          map[string]any    `json:"payload"`
	Headers          map[string]any    `json:"headers,omitempty"`
	Status           EventStatus       `json:"status"`
	Priority         int               `json:"priority"`
	ScheduledAt      *time.Time        `json:"scheduledAt,omitempty"`
	Attempts         int               `json:"attempts"`
	MaxAttempts      int               `json:"maxAttempts"`
	NextAttemptAt    *time.Time        `json:"nextAttemptAt,omitempty"`
	DeliveredAt      *time.Time        `json:"deliveredAt,omitempty"`
	CreatedAt        time.Time         `json:"createdAt"`
	UpdatedAt        time.Time         `json:"updatedAt"`
	DeliveryAttempts []DeliveryAttempt `json:"deliveryAttempts"`
	Endpoint         *Endpoint         `json:"endpoint,omitempty"`
}

type EventConnection struct {
	Edges      []EventEdge `json:"edges"`
	PageInfo   *PageInfo   `json:"pageInfo"`
	TotalCount int         `json:"totalCount"`
}

type EventEdge struct {
	Node   *Event `json:"node"`
	Cursor string `json:"cursor"`
}

type EventType struct {
	ID            string         `json:"id"`
	ClientID      string         `json:"clientId"`
	Name          string         `json:"name"`
	Description   *string        `json:"description,omitempty"`
	Schema        map[string]any `json:"schema,omitempty"`
	SchemaVersion *string        `json:"schemaVersion,omitempty"`
	CreatedAt     time.Time      `json:"createdAt"`
	UpdatedAt     time.Time      `json:"updatedAt"`
}

type EventTypeConnection struct {
	Edges      []EventTypeEdge `json:"edges"`
	PageInfo   *PageInfo       `json:"pageInfo"`
	TotalCount int             `json:"totalCount"`
}

type EventTypeEdge struct {
	Node   *EventType `json:"node"`
	Cursor string     `json:"cursor"`
}

type FIFODrainResult struct {
	EndpointID      string  `json:"endpointId"`
	PartitionKey    *string `json:"partitionKey,omitempty"`
	MessagesDrained int     `json:"messagesDrained"`
	MovedToStandard bool    `json:"movedToStandard"`
}

type FIFOEndpointStats struct {
	EndpointID          string           `json:"endpointId"`
	TotalPartitions     int              `json:"totalPartitions"`
	TotalQueuedMessages int              `json:"totalQueuedMessages"`
	Partitions          []FIFOQueueStats `json:"partitions"`
}

type FIFOQueueStats struct {
	EndpointID   string `json:"endpointId"`
	PartitionKey string `json:"partitionKey"`
	QueueLength  int    `json:"queueLength"`
	IsLocked     bool   `json:"isLocked"`
	HasInFlight  bool   `json:"hasInFlight"`
}

type FIFORecoveryResult struct {
	MessagesRecovered int `json:"messagesRecovered"`
}

type LatencyPercentiles struct {
	P50 float64 `json:"p50"`
	P95 float64 `json:"p95"`
	P99 float64 `json:"p99"`
}

type Mutation struct {
}

type PageInfo struct {
	HasNextPage     bool    `json:"hasNextPage"`
	HasPreviousPage bool    `json:"hasPreviousPage"`
	StartCursor     *string `json:"startCursor,omitempty"`
	EndCursor       *string `json:"endCursor,omitempty"`
}

type PriorityQueueStats struct {
	High    int `json:"high"`
	Normal  int `json:"normal"`
	Low     int `json:"low"`
	Delayed int `json:"delayed"`
}

type Query struct {
}

type QueueStats struct {
	Queued     int `json:"queued"`
	Delivering int `json:"delivering"`
	Delivered  int `json:"delivered"`
	Failed     int `json:"failed"`
	Dead       int `json:"dead"`
	Pending    int `json:"pending"`
	Processing int `json:"processing"`
	Delayed    int `json:"delayed"`
}

type SendEventInput struct {
	EventType    string         `json:"eventType"`
	Payload      map[string]any `json:"payload"`
	Headers      map[string]any `json:"headers,omitempty"`
	Priority     *int           `json:"priority,omitempty"`
	DeliverAt    *time.Time     `json:"deliverAt,omitempty"`
	DelaySeconds *int           `json:"delaySeconds,omitempty"`
}

type TestTransformationInput struct {
	Code    string        `json:"code"`
	Webhook *WebhookInput `json:"webhook"`
}

type TimeSeriesPoint struct {
	Timestamp time.Time `json:"timestamp"`
	Value     float64   `json:"value"`
}

type TransformationResult struct {
	Method  string         `json:"method"`
	URL     string         `json:"url"`
	Headers map[string]any `json:"headers,omitempty"`
	Payload map[string]any `json:"payload,omitempty"`
	Cancel  bool           `json:"cancel"`
}

type TransformationTestResult struct {
	Success     bool                  `json:"success"`
	Result      *TransformationResult `json:"result,omitempty"`
	Error       *string               `json:"error,omitempty"`
	ExecutionMs int                   `json:"executionMs"`
}

type UpdateAlertRuleInput struct {
	Name        *string              `json:"name,omitempty"`
	Description *string              `json:"description,omitempty"`
	Enabled     *bool                `json:"enabled,omitempty"`
	Condition   *AlertConditionInput `json:"condition,omitempty"`
	Action      *AlertActionInput    `json:"action,omitempty"`
	Cooldown    *string              `json:"cooldown,omitempty"`
}

type UpdateConnectorInput struct {
	Config   *ConnectorConfigInput   `json:"config,omitempty"`
	Template *ConnectorTemplateInput `json:"template,omitempty"`
}

type UpdateEndpointInput struct {
	URL              *string         `json:"url,omitempty"`
	Description      *string         `json:"description,omitempty"`
	EventTypes       []string        `json:"eventTypes,omitempty"`
	Status           *EndpointStatus `json:"status,omitempty"`
	Filter           map[string]any  `json:"filter,omitempty"`
	Transformation   *string         `json:"transformation,omitempty"`
	Fifo             *bool           `json:"fifo,omitempty"`
	FifoPartitionKey *string         `json:"fifoPartitionKey,omitempty"`
	MaxRetries       *int            `json:"maxRetries,omitempty"`
	RetryBackoffMs   *int            `json:"retryBackoffMs,omitempty"`
	RetryBackoffMax  *int            `json:"retryBackoffMax,omitempty"`
	RetryBackoffMult *float64        `json:"retryBackoffMult,omitempty"`
	TimeoutMs        *int            `json:"timeoutMs,omitempty"`
	RateLimitPerSec  *int            `json:"rateLimitPerSec,omitempty"`
	CircuitThreshold *int            `json:"circuitThreshold,omitempty"`
	CircuitResetMs   *int            `json:"circuitResetMs,omitempty"`
	CustomHeaders    map[string]any  `json:"customHeaders,omitempty"`
}

type UpdateEventTypeInput struct {
	Description   *string        `json:"description,omitempty"`
	Schema        map[string]any `json:"schema,omitempty"`
	SchemaVersion *string        `json:"schemaVersion,omitempty"`
}

type WebhookInput struct {
	Method  *string        `json:"method,omitempty"`
	URL     string         `json:"url"`
	Headers map[string]any `json:"headers,omitempty"`
	Payload map[string]any `json:"payload"`
}

type AlertActionType string

const (
	AlertActionTypeSLACk     AlertActionType = "SLACK"
	AlertActionTypeEmail     AlertActionType = "EMAIL"
	AlertActionTypeWebhook   AlertActionType = "WEBHOOK"
	AlertActionTypePagerduty AlertActionType = "PAGERDUTY"
)

var AllAlertActionType = []AlertActionType{
	AlertActionTypeSLACk,
	AlertActionTypeEmail,
	AlertActionTypeWebhook,
	AlertActionTypePagerduty,
}

func (e AlertActionType) IsValid() bool {
	switch e {
	case AlertActionTypeSLACk, AlertActionTypeEmail, AlertActionTypeWebhook, AlertActionTypePagerduty:
		return true
	}
	return false
}

func (e AlertActionType) String() string {
	return string(e)
}

func (e *AlertActionType) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = AlertActionType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid AlertActionType", str)
	}
	return nil
}

func (e AlertActionType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *AlertActionType) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e AlertActionType) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

type AlertMetric string

const (
	AlertMetricFailureRate   AlertMetric = "FAILURE_RATE"
	AlertMetricSuccessRate   AlertMetric = "SUCCESS_RATE"
	AlertMetricLatency       AlertMetric = "LATENCY"
	AlertMetricQueueDepth    AlertMetric = "QUEUE_DEPTH"
	AlertMetricErrorCount    AlertMetric = "ERROR_COUNT"
	AlertMetricDeliveryCount AlertMetric = "DELIVERY_COUNT"
)

var AllAlertMetric = []AlertMetric{
	AlertMetricFailureRate,
	AlertMetricSuccessRate,
	AlertMetricLatency,
	AlertMetricQueueDepth,
	AlertMetricErrorCount,
	AlertMetricDeliveryCount,
}

func (e AlertMetric) IsValid() bool {
	switch e {
	case AlertMetricFailureRate, AlertMetricSuccessRate, AlertMetricLatency, AlertMetricQueueDepth, AlertMetricErrorCount, AlertMetricDeliveryCount:
		return true
	}
	return false
}

func (e AlertMetric) String() string {
	return string(e)
}

func (e *AlertMetric) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = AlertMetric(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid AlertMetric", str)
	}
	return nil
}

func (e AlertMetric) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *AlertMetric) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e AlertMetric) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

type AlertOperator string

const (
	AlertOperatorGt  AlertOperator = "GT"
	AlertOperatorGte AlertOperator = "GTE"
	AlertOperatorLt  AlertOperator = "LT"
	AlertOperatorLte AlertOperator = "LTE"
	AlertOperatorEq  AlertOperator = "EQ"
	AlertOperatorNe  AlertOperator = "NE"
)

var AllAlertOperator = []AlertOperator{
	AlertOperatorGt,
	AlertOperatorGte,
	AlertOperatorLt,
	AlertOperatorLte,
	AlertOperatorEq,
	AlertOperatorNe,
}

func (e AlertOperator) IsValid() bool {
	switch e {
	case AlertOperatorGt, AlertOperatorGte, AlertOperatorLt, AlertOperatorLte, AlertOperatorEq, AlertOperatorNe:
		return true
	}
	return false
}

func (e AlertOperator) String() string {
	return string(e)
}

func (e *AlertOperator) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = AlertOperator(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid AlertOperator", str)
	}
	return nil
}

func (e AlertOperator) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *AlertOperator) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e AlertOperator) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

type ConnectorType string

const (
	ConnectorTypeSLACk   ConnectorType = "SLACK"
	ConnectorTypeDiscord ConnectorType = "DISCORD"
	ConnectorTypeTeams   ConnectorType = "TEAMS"
	ConnectorTypeEmail   ConnectorType = "EMAIL"
	ConnectorTypeWebhook ConnectorType = "WEBHOOK"
)

var AllConnectorType = []ConnectorType{
	ConnectorTypeSLACk,
	ConnectorTypeDiscord,
	ConnectorTypeTeams,
	ConnectorTypeEmail,
	ConnectorTypeWebhook,
}

func (e ConnectorType) IsValid() bool {
	switch e {
	case ConnectorTypeSLACk, ConnectorTypeDiscord, ConnectorTypeTeams, ConnectorTypeEmail, ConnectorTypeWebhook:
		return true
	}
	return false
}

func (e ConnectorType) String() string {
	return string(e)
}

func (e *ConnectorType) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ConnectorType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ConnectorType", str)
	}
	return nil
}

func (e ConnectorType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *ConnectorType) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e ConnectorType) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

type EndpointStatus string

const (
	EndpointStatusActive   EndpointStatus = "ACTIVE"
	EndpointStatusPaused   EndpointStatus = "PAUSED"
	EndpointStatusDisabled EndpointStatus = "DISABLED"
)

var AllEndpointStatus = []EndpointStatus{
	EndpointStatusActive,
	EndpointStatusPaused,
	EndpointStatusDisabled,
}

func (e EndpointStatus) IsValid() bool {
	switch e {
	case EndpointStatusActive, EndpointStatusPaused, EndpointStatusDisabled:
		return true
	}
	return false
}

func (e EndpointStatus) String() string {
	return string(e)
}

func (e *EndpointStatus) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = EndpointStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid EndpointStatus", str)
	}
	return nil
}

func (e EndpointStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *EndpointStatus) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e EndpointStatus) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

type EventStatus string

const (
	EventStatusQueued     EventStatus = "QUEUED"
	EventStatusDelivering EventStatus = "DELIVERING"
	EventStatusDelivered  EventStatus = "DELIVERED"
	EventStatusFailed     EventStatus = "FAILED"
	EventStatusDead       EventStatus = "DEAD"
)

var AllEventStatus = []EventStatus{
	EventStatusQueued,
	EventStatusDelivering,
	EventStatusDelivered,
	EventStatusFailed,
	EventStatusDead,
}

func (e EventStatus) IsValid() bool {
	switch e {
	case EventStatusQueued, EventStatusDelivering, EventStatusDelivered, EventStatusFailed, EventStatusDead:
		return true
	}
	return false
}

func (e EventStatus) String() string {
	return string(e)
}

func (e *EventStatus) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = EventStatus(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid EventStatus", str)
	}
	return nil
}

func (e EventStatus) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *EventStatus) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e EventStatus) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}

type TimeGranularity string

const (
	TimeGranularityMinute TimeGranularity = "MINUTE"
	TimeGranularityHour   TimeGranularity = "HOUR"
	TimeGranularityDay    TimeGranularity = "DAY"
	TimeGranularityWeek   TimeGranularity = "WEEK"
)

var AllTimeGranularity = []TimeGranularity{
	TimeGranularityMinute,
	TimeGranularityHour,
	TimeGranularityDay,
	TimeGranularityWeek,
}

func (e TimeGranularity) IsValid() bool {
	switch e {
	case TimeGranularityMinute, TimeGranularityHour, TimeGranularityDay, TimeGranularityWeek:
		return true
	}
	return false
}

func (e TimeGranularity) String() string {
	return string(e)
}

func (e *TimeGranularity) UnmarshalGQL(v any) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = TimeGranularity(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid TimeGranularity", str)
	}
	return nil
}

func (e TimeGranularity) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

func (e *TimeGranularity) UnmarshalJSON(b []byte) error {
	s, err := strconv.Unquote(string(b))
	if err != nil {
		return err
	}
	return e.UnmarshalGQL(s)
}

func (e TimeGranularity) MarshalJSON() ([]byte, error) {
	var buf bytes.Buffer
	e.MarshalGQL(&buf)
	return buf.Bytes(), nil
}
